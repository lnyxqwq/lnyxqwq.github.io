<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小清新 ds</title>
    <link href="/2023/08/15/%E5%B0%8F%E6%B8%85%E6%96%B0%20ds/"/>
    <url>/2023/08/15/%E5%B0%8F%E6%B8%85%E6%96%B0%20ds/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/d4ch8cfq.png" alt=""></p><p><img src="http://%E5%9B%BE.tk/q" alt=""><img src="http://%E5%9B%BE.tk/q" alt=""><img src="http://%E5%9B%BE.tk/q" alt=""></p><h2 id="线段树">线段树</h2><h3 id="我也不知道该分到哪里">我也不知道该分到哪里</h3><h4 id="GSS3-Can-you-answer-these-queries-III"><a href="https://www.luogu.com.cn/problem/SP1716">GSS3 - Can you answer these queries III</a></h4><p>经典最大子段和</p><p>维护前缀 $\max$ ，后缀 $\max$ ，和区间最大子段，区间和就好了</p><p><a href="https://www.luogu.com.cn/record/110838045">code</a></p><h4 id="2055-「TJOI-HEOI2016」排序"><a href="https://loj.ac/p/2055">#2055. 「TJOI / HEOI2016」排序</a></h4><p>首先有一个经典做法，就是二分答案，将大于 $ans$ 的值设为 $1$ ，小于 $ans$ 设为 $0$ ，这样排序就很好做了，时间复杂度 $O(n\log^2 n)$</p><p>但是其实还有 $O(n\log n)$ 的做法，就是你那权值线段树维护序列的连续有序段，每次操作相当于合并一些线段树，倒序就打一个 $tag$ 就好了，注意边界可能在一颗线段树里面，所以还需要线段树分裂，这样复杂度就是 $O(n\log n)$ 了，因为你发现你一次操作最多分裂出来两颗线段树，所以合并是 $O(n+m)$ 次</p><p>代码写一半丢了所以开摆了</p><h4 id="CF1783G-Weighed-Tree-Radius"><a href="https://www.luogu.com.cn/problem/CF1783G">CF1783G Weighed Tree Radius</a></h4><p>首先将权值 $a_i$ 转变成向外挂一个点，边权为 $a_i$ （注意这里要挂两个，因为 $w_v(v)$ 是合法的</p><p>发现这个半径好像很不好做，<s>再根据他的名字联想</s>，我们可以想到求出直径，最后输出 $\lceil \frac{len}{2} \rceil$ ，至于为什么这样是对的，因为离每个点最远的点一定都是直径上的点，所以中点是半径最小的</p><p>现在问题就好做了，边权修改，直径查询，用线段树维护即可，具体来说，就是根据直径性质，两颗树合并到一块新的直径端点一定出自原来两棵树的四个直径端点中，可以合并</p><p>因为常数巨大，所以我写了 $O(1)\ LCA$ 但是 <a href="https://www.luogu.com.cn/user/265453">$\text{strange757}$</a> 实测 $O(n\log^2n)$ 可过</p><p><a href="https://codeforces.com/contest/1783/submission/197115998">code</a> （u1s1，我不知道我写的是什么</p><h4 id="CF1192B-Dynamic-Diameter"><a href="https://www.luogu.com.cn/problem/CF1192B">CF1192B Dynamic Diameter</a></h4><p>线段树维护直径板子</p><p>线段树维护 $dfn$ 序，每个点到根节点的权值用 $bit$ 维护，修改 $(u,v)$ 时重新算一下所有包含 $u$ 的和包含 $u+sz_u-1$ 的就行了</p><p><a href="https://codeforces.com/contest/1192/submission/206692637">code</a></p><h4 id="CF1149C-Tree-Generator™"><a href="https://www.luogu.com.cn/problem/CF1149C">CF1149C Tree Generator™</a></h4><p>$($ 表示往下做一步，所以深度 $+1$ ，同理 $)$ 导致深度减 $1$ ，所以设 $($ 为 $1$ ，$)$ 为 $-1$</p><p>然后就有一个很牛逼的东西了，我们可以把一条长度为 $x+y$ 路径 $u,v$ 看成 $u$ 先走 $x$ 个 $-1$ 走到 $lca(u,v)$ ，然后走 $y$ 个 $1$ 走到 $y$ ，发现这个玩意可以直接转到括号序上，因为我要是在递归 $u$ 所在子树和递归 $v$ 所在子树中间递归了其他子树，这是肯定会回溯上来的，所以算上这一段也不会对答案有影响，现在就是等于把题意转化成了：给定一个 $1,-1$ 序列，单点修改，查询 $\max\limits_{1 \le l \le r \le n}sum_{k+1,r}-sum_{l,k},k\in[l-1,r]$ ，其中 $sum_{l,r}$ 表示 $[l,r]$ 这一段的权值和，这个玩意就可以用线段树维护了</p><p>具体来说，我们设 $ans$ 为要求的答案，现在枚举 $k$ 在 $[l,mid]$ 还是在 $(mid,r]$ ，下面说的全局 $ans$ 最大值就是 $l,r$ 和区间 $l,r$ 相同，前缀/后缀 $ans$ 最大值就是固定前缀/后缀是 $l/r$ 的 $ans$ 最大值</p><p>当 $k$ 在 $[l,mid]$ 时需要一个右区间的前缀权值 $\max$ 拼在后面，左区间需要一个后缀 $ans$ 最大值，$k$ 在 $(mid,r]$ 时同理左区间后缀权值 $\min$ ，右区间前缀 $ans$  最大值， 考虑前缀/后缀 $ans$ 最大值要怎么求，这个就是需要全局 $ans$ 最大值，然后前缀权值 $\max$ 还需要一个区间权值和，将这些都维护上就好了</p><p><a href="https://codeforces.com/contest/1149/submission/206790063">code</a></p><h3 id="线段树合并">线段树合并</h3><p><s>我发现这玩意是纯傻逼，啥都过不去</s></p><h4 id="3046-「ZJOI2019」语言"><a href="https://loj.ac/p/3046">#3046. 「ZJOI2019」语言</a></h4><p>我们对于每个点求出所有他能到的点，不难发现这肯定是一个连通块，现在考虑怎么快速计算这个连通块内有多少点，因为原图是树，所以这个连通块一定是树，考虑什么点会跟当前点 $u$ 联通，肯定是经过了经过 $u$ 的链，所以我们将所有经过 $u$ 的链进行链覆盖，这个可以树上差分，而树上差分有一个很经典的东西，就是将 $p_1,p_2,p_3,…,p_n$ 两两相连构成的连通块覆盖等于将 $p$ 按 $dfn$ 序排序，对于 $p_i$ 加一，对于 $lca(p_i,p_i+1)$ 和 $lca(p_1,p_2,p_3,…,p_n)$ 减一，这个题我们也可以这样，但是这样复杂度依然很高，继续优化</p><p>发现我对于每一个点都算很亏，发现答案其实就是加一的点的 $dep$ 减去减一的点的 $dep$ ，这样虽然复杂度没变，但是这个显然比刚才那个好优化</p><p>发现你子树里面的很多信息当前点也可以用，考虑线段树合并，线段树区间 $l,r$ 维护 $dfn$ 序在 $l,r$ 时所有关键点和 $1$ 号点能覆盖的点的数量，其中关键点就是每条链的链首链尾，对于一条链 $u,v$ ，我们让他在 $u,v$ 时都加入关键点 $u,v$ 在 $lca(u,v)$ 的时候在都减回来，用上面说的那个 $dep$ 求方法维护一下就可以了</p><p><a href="https://loj.ac/s/1780826">code</a></p><h4 id="2537-「PKUWC2018」Minimax"><a href="https://loj.ac/p/2537">#2537. 「PKUWC2018」Minimax</a></h4><p>不是很难</p><p>首先先想一下暴力 $dp$ ，设 $f_{u,j}$ 表示现在在节点 $u$ ，权值是 $v_j$ 的概率，因为只有最多两个子节点，所以很好转移，时间复杂度 $O(n^3)$ ，可以优化，但是不重要</p><p>现在考虑用线段树合并优化这个东西，在合并区间 $l,r$ 的时候维护左/右儿子权值是 $[v_1,v_{l-1}]$ ， $[v_{l+1},v_r]$ 的概率，直接线段树合并就可以了</p><p><a href="https://loj.ac/s/1760862">code</a></p><h4 id="3340-「NOI2020」命运"><a href="https://loj.ac/p/3340">#3340. 「NOI2020」命运</a></h4><p>好强的 $dp$ 状态</p><p>考虑 $dp$ ，设 $f_{u,j}$ 表示我现在在 $u$ 节点，目前不满足要求的属于 $Q$ 人生经历在第 $j$ 层结束，特殊的， $j=0$ 时表示没有属于 $Q$ 的不满足要求的人生经历</p><p>转移就很好转移了，假设我现在在点 $u$ ，我要把 $v$ 的 $dp$ 转移过来，有柿子：</p><p>$f_{u,j}=\sum\limits_{i=0}^{dep_u} f_{u,j}\times f_{v,i}+\sum\limits_{i=0}^{j}f_{u,j}\times f_{v,i}+\sum\limits_{i=0}^{j-1}f_{v,j}\times f_{u,i}$ ，第一个 $\sum$ 是这条边为 $0$ ，后面两个 $\sum$ 为 $1$</p><p>这个玩意拿前缀和优化一下就是 $O(n^2)$ 的了，能拿到 $40pts$ ，考虑优化，<s>因为刚刚做了 Minimax</s> 我们知道线段树合并是可以搞前后缀 $dp$ 的，所以直接线段树合并就可以了</p><p><a href="https://loj.ac/s/1781138">code</a></p><h3 id="李超树">李超树</h3><h4 id="P4097-HEOI2013-Segment"><a href="https://www.luogu.com.cn/problem/P4097">P4097 [HEOI2013] Segment</a></h4><p>李超树区间插线段板子</p><p><a href="https://www.luogu.com.cn/record/105890686">code</a> 自认为写的还是能看的</p><h4 id="P4655-CEOI2017-Building-Bridges"><a href="https://www.luogu.com.cn/problem/P4655">P4655 [CEOI2017] Building Bridges</a></h4><p>李超树优化 $dp$</p><p>这玩意做斜率优化 $dp$ 都不用动脑子的</p><p>先搞一个 $dp$ ，设 $f_i$ 表示我现在不拆第 $i$ 根柱子将桥从 $1$ 架到 $i$ 的最小花费，不难发现转移是枚举上一个没拆的主子 $f_i=\min\limits_{j=1}^{i-1}{f_j+sum_{i-1}-sum_j+(h_i-h_j)^2}$ ，好棒！</p><p>考虑优化，这是一个标准的斜率优化柿子，化简一下有</p><p>$f_i=\min\limits_{j=1}^{i-1}{f_j+sum_{i-1}-sum_j+{h_i}^2+{h_j}^2-2h_ih_j}$</p><p>$f_i=\min\limits_{j=1}^{i-1}{f_j-sum_j+{h_j}^2-2h_ih_j}+sum_{i-1}+{h_i}^2$</p><p>外面的常数都不用考虑，只看里面</p><p>将每一个 $f_j$ 看成斜率是 $-2h_j$ 截距是 $f_j-sum_j+{h_j}^2$ 现在就等于有一堆直线，我们要查询位置 $h_i$ 的最小值，直接上李超树就行了</p><h4 id="CF932F-Escape-Through-Leaf"><a href="https://www.luogu.com.cn/problem/CF932F">CF932F Escape Through Leaf</a></h4><p>李超树线段树合并</p><p>设 $f_u$ 表示从 $u$ 走到叶子节点的最小代价，转移就是 $f_u=\min\limits_{v}{f_v+a_u\times b_v}$ ，这玩意就是一个标准的斜率优化，直接李超树合并就行了</p><p>至于怎么李超树合并，其实就是暴力，差不多就是把一颗李超树里面的所有直线全部插进另一颗里面，具体可以看代码，但是注意这个时间复杂度其实是 $O(n \log n)$ 的，因为线段树的深度是 $O(\log n)$ 的，是所以每条线段最多向下走 $O(\log n)$ 次，所以复杂度是 $O(n\log n)$</p><p><a href="https://codeforces.com/contest/932/submission/199104837">code</a></p><h3 id="兔队线段树">兔队线段树</h3><p>就是如果前缀会影响当前节点的情况的时候可以考虑用这个东西</p><h4 id="P4198-楼房重建"><a href="https://www.luogu.com.cn/problem/P4198">P4198 楼房重建 </a></h4><p>下面说的楼的高度均除以 $i$</p><p>对于线段树上每个点维护只考虑当前区间 $[l,r]$ 的所有楼，能看见几栋楼，现在考虑怎么更新，我们定义一个函数 $calc$ 表示考虑 $[l,r]$ ，$[1,l)$ 中楼的最高高度为 $pre$ ，这段区间内有多少楼能看见，设 $mid$ 为当前区间中点，$mx$ 表示区间最大值，假设 $[l,mid]$ 的 $mx$ 小于 $pre$ ，那么左区间一个都不可能在当前区间答案里面，直接递归右区间就可以了，假设 $[l,mid]$ 的 $mx$ 大于 $pre$ ，那么右区间是不受 $pre$ 影响的，只用递归左区间，这样 $calc$ 的时间复杂度是 $O(\log n)$ 的，不难发现有了这个就很容易算线段树上维护的东西了</p><p>注意到我要是想知道 $(mid,r]$ 受到 $[l,mid]$ 影响时的答案是需要减的，但是可能其他题维护的东西没有可减性，所以可以线段树每个区间维护在左区间影响下右区间的答案，这样就不用减法了</p><p><a href="https://www.luogu.com.cn/record/102474233">code</a></p><h4 id="P9130-USACO23FEB-Hungry-Cow-P"><a href="https://www.luogu.com.cn/problem/P9130">P9130 [USACO23FEB] Hungry Cow P</a></h4><p>还是考虑兔队线段树，每个节点维护 $cnt,sum,to$ 表示当前区间有几天有干草，右区间有干草的日期编号和和给后面的区间贡献多少干草，还是搞一个 $calc$ 函数，要是左区间加上前面贡献过来的已经填满了就直接等差数列加起来就可以了，然后递归右区间，要是没加满就说明这个不会贡献到右区间，只用重新算左区间</p><p><a href="https://www.luogu.com.cn/record/104132904">code</a> 代码<s>非常</s>比较抽象</p><h4 id="CF671E-Organizing-a-Race"><a href="https://www.luogu.com.cn/problem/CF671E">CF671E Organizing a Race</a></h4><h3 id="segbeats">segbeats</h3><p>等我闲的没事的时候再写吧</p><h3 id="主席树">主席树</h3><h4 id="2016-「SCOI2016」美味"><a href="https://loj.ac/p/2016">#2016. 「SCOI2016」美味</a></h4><p>看见异或直接上 $trie$ ，然后不会做，$trie$ 好像根本不能平移 👈🤣</p><p>但是主席树可以干这个玩意 😎</p><p>贪心从高位考虑到低位看一看这一位异或后能不能是 $1$ ，因为前面位的 $01$ 已经确定，所以这一位是 $1$ 的位置肯定连续，减 $x_i$ 后也一定连续，在权值线段树上查就行了，区间交给主席树</p><p>时间复杂度 $O(n\log^2 n)$</p><p><a href="https://loj.ac/s/1779516">code</a></p><p><a href="https://www.luogu.com.cn/blog/command-block/guan-yu-xian-duan-shu-shang-di-yi-suo-jin-jie-cao-zuo">关于线段树上的一些进阶操作 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a></p><h2 id="cdq-分治">cdq 分治</h2><p>一个我非常讨厌的算法，虽然我也不知道为什么</p><h2 id="平衡树">平衡树</h2><h2 id="根号">根号</h2><h3 id="分块">分块</h3><h4 id="6282-数列分块入门-6-题目-LibreOJ"><a href="https://loj.ac/p/6282">#6282. 数列分块入门 6 - 题目 - LibreOJ</a></h4><p>操作：单点插入，单点询问</p><p>也没啥，数据随机就直接插就行了，数据要是不随机就定期重构一下，<s>块长我也不知道设多少合适</s></p><p><a href="https://loj.ac/s/1679907">code</a></p><h4 id="6284-数列分块入门-8-题目-LibreOJ"><a href="https://loj.ac/p/6284">#6284. 数列分块入门 8 - 题目 - LibreOJ</a></h4><p>发现一次修改最多把两个块内数全相同的改成不是全相同的所以块内数不同的只有 $O(n)$ 个，直接做就好了</p><p><s>不如线段树</s></p><h4 id="6285-数列分块入门-9-题目-LibreOJ"><a href="https://loj.ac/p/6285">#6285. 数列分块入门 9 - 题目 - LibreOJ</a></h4><p>挺强的</p><p>早就忘了 🐸</p><p>$O(n\sqrt{n \log n})$ ：等我想起来再写</p><p>$O(n\sqrt n)$ ：</p><p>要是询问两边块编号一样直接暴力</p><p>要是不一样发现可能的众数只有 $\sqrt n$ 种：散块部分出现的数和所有整块的众数</p><p>预处理出 $A_{i,j}$ 表示第 $j$ 个数在块 $[1,i]$ 中出现次数， $B_{i,j}$ 表示块 $[i,j]$ 的众数，直接做就行了</p><h4 id="P5356-Ynoi2017-由乃打扑克"><a href="https://www.luogu.com.cn/problem/P5356">P5356 [Ynoi2017] 由乃打扑克</a></h4><p>其实不是很难</p><p>首先有一个一眼的方法，对于每个块维护块内数排序后的结果，修改时散块直接暴力重构，整块打标记，查询就先二分答案，然后再对于每一个块二分求出有多少数小于等于第一个二分的答案，这样散块复杂度是 $O(B\log B)$ ，整块复杂度是 $O(\frac{n}{B}\log w \log B)$ ，其中 $w$ 是值域，将 $\log w,\log B$ 视为同阶，平衡复杂度后复杂度为 $O(q\sqrt{n\log B}\log B)$ ，寄！</p><p>发现我修改的时候散块加的东西都一样，所以可以改成归并排序来去掉一个 $\log$ ，现在平衡完复杂度是 $O(q\sqrt n\log B)$ ，卡卡常就能过了</p><p>卡常也很简单，首先可以记录下来块内最大最小值，缩小二分范围，还有一个是再对于整块查询有多少个数 $\le x$ 时可以特判掉一个数都没有/所有数都 $\le x$ 的情况</p><p>块长大概 $200$ 最快</p><p><a href="https://www.luogu.com.cn/paste/mqyxi98r">code</a></p><h4 id="P3203-HNOI2010-弹飞绵羊"><a href="https://www.luogu.com.cn/problem/P3203">P3203 [HNOI2010]弹飞绵羊</a></h4><p>对于每个位置求出跳出当前块的最小步数和跳出去后的位置，修改就暴力重构块，查询就暴力往后跳块，时间复杂度 $O(q\log n)$</p><h4 id="P4135-作诗"><a href="https://www.luogu.com.cn/problem/P4135">P4135 作诗</a></h4><p>设 $f_{i,j}$ 表示第 $i$ 个块到第 $j$ 个块的答案， $sum_{i,j}$ 表示数 $i$ 在块 $1$ 到 $j$ 出现次数，不难发现只要求出这连个答案就很好求了。</p><p>$sum$ 很好求，现在考虑 $f$ 怎么求，我固定一个左端点 $i$ ，然后往后扫求出每个 $j$ 的答案，这样复杂度是 $n \sqrt n$ ，可以接受</p><p>还有一个 $O(\frac{n^2}{\omega})$ 的做法，到时候再写吧</p><h4 id="6546-简单的数列题"><a href="https://loj.ac/p/6546">#6546. 简单的数列题</a></h4><h3 id="莫队">莫队</h3><h4 id="CF617E-XOR-and-Favorite-Number"><a href="https://www.luogu.com.cn/problem/CF617E">CF617E XOR and Favorite Number</a></h4><p>首先先做一个异或前缀和，现在就把问题转变成了区间内有多少点异或值为 $k$ ，发现这个东西好像什么 ds 都干不了，所以考虑莫队，莫队维护区间每个权值的点数，直接做就行了</p><p><a href="https://www.luogu.com.cn/blog/command-block/fen-kuai-xiang-guan-za-tan">分块相关杂谈 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a></p><p><a href="https://www.luogu.com.cn/blog/command-block/mu-dui-yang-xie">莫队略解 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a></p><h2 id="LCT">LCT</h2><p><a href="https://www.luogu.com.cn/blog/command-block/lct-xiao-ji">LCT小记 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a></p><h2 id="树剖">树剖</h2><h2 id="KDT">KDT</h2>]]></content>
    
    
    
    <tags>
      
      <tag>ds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数学习笔记</title>
    <link href="/2023/08/15/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/15/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yr9gjmhl.png" alt=""></p><p>注：除了上面那张图都是贺的 <a href="https://space.bilibili.com/88461692">$\text{3Blue1Brown}$</a> 的</p><h3 id="向量">向量</h3><p>向量可以是任何东西，只要保证两个向量相加以及数字与向量相乘是有意义的即可</p><p>向量加法：</p><p>$\vec{v}+\vec{w}$ 如图：</p><p><img src="https://sjzezoj.com/image_hosting/il3p69604k.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/rtqfskxy12.png" alt=""></p><p>为什么是这样定义的？</p><p>可以将向量看成一种特定的运动，即在空间中按照向量方向走他的长度的距离，这样定义加法时走 $\vec{v}$ 和走 $\vec{w}$ 是等同于走 $\vec{v}+\vec{w}$ 的</p><p>考虑矩阵<br>$$<br>\begin{bmatrix}<br>x \<br>y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>a \<br>b<br>\end{bmatrix}<br>$$<br>等于先沿纵坐标方向走 $x$ 距离，然后沿横坐标方向走 $y$ 距离，沿纵坐标方向走 $a$ 距离，然后沿横坐标方向走 $b$ 距离，所以上面两个矩阵加完就是<br>$$<br>\begin{bmatrix}<br>x+a \<br>y+b<br>\end{bmatrix}<br>$$<br>向量数乘：</p><p>$a\vec{x}$ 等于把向量 $x$ 拉长 $a$ 倍</p><h1>这种过程被称为缩放 $a$ 被称为标量，在线性代数中数字的主要作用就是缩放向量<br>$$<br>a<br>\begin{bmatrix}<br>x \<br>y<br>\end{bmatrix}</h1><h1>\begin{bmatrix}<br>a\times x \<br>b\times y<br>\end{bmatrix}<br>$$<br>矩阵<br>$$<br>\begin{bmatrix}<br>x \<br>y<br>\end{bmatrix}<br>$$<br>可以表示为 $x\times \hat{i}+y \times \hat{j}$<br>$$<br>\hat{i}</h1><p>\begin{bmatrix}<br>1 \<br>0<br>\end{bmatrix}<br>,\hat{j}=<br>\begin{bmatrix}<br>0 \<br>1<br>\end{bmatrix}<br>$$<br>$\hat{i}$ 与 $\hat{j}$ 是 $xy$ 坐标系的基向量</p><p>当然基向量也可以不选这俩，只要不共线就行了</p><p>当用数字描述向量时，都依赖于正在使用的基</p><p>$a\vec{v}+b\vec{w}$ 被称为两个向量的<strong>线性组合</strong></p><p>为啥叫线性组合？</p><p>将一个标量固定，发现这两个向量加起来后产生的向量的终点在一条直线上（$3B1B$ 这样说的</p><p>将两个标量同时改变，如果不共线则可以组合出所有二维平面中的向量，但是共线时时一条直线<img src="http://%E5%9B%BE.tk/q" alt=""></p><p>所有可以表示为给定向量线性组合的向量构成的集合被称为给定向量张成的空间($\text{span}$)</p><p><strong>向量与点</strong>：通常用向量的终点代表该向量</p><p>三维空间中的张成空间</p><p>两个三维向量张成的空间是一个二维平面</p><p><img src="https://sjzezoj.com/image_hosting/llhflsj7pf.png" alt=""></p><p>那当加上第三个向量呢？</p><p>线性组合的定义是很像的 $a\vec{v}+b\vec{w}+c\vec{u}$</p><p>如果第三个向量落在了前两个向量的平面上，那就还是在这个平面上否则能得到所有三维向量</p><p>更高维的我不会了，可以让 [$sls$] 帮你想一下</p><p>要是有多个向量，并且可以在不改变张成空间大小的情况下移除一些向量，则称这些向量是<strong>线性相关</strong>的</p><p>另一种表述是其中一个向量可以被表示为其他向量的线性组合</p><p>否则就是线性无关的了</p><p><strong>向量空间的一组基是张成该空间的一个线性无关向量集</strong></p><h3 id="矩阵与线性变换">矩阵与线性变换</h3><p>变换：就是函数的一个其他叫法，输入一些东西，输出所对应的东西，在线性代数中考虑的是向量输入输出</p><p>为什么叫变换不叫函数？就是暗示可以通过特定方式来可视化变换关系</p><p>线性代数限制在了一种特殊的变换上，<strong>线性变换</strong></p><p>线性变换性质：</p><ol><li>直线变换后仍为直线</li><li>原点必须保持固定</li></ol><p>可以把线性变换看作“保持网格线平行且等距分别“的变换</p><p>你只要知道 $\hat{i}$ 和 $\hat{j}$ 变换后的位置就能求出所有向量了，因为这俩是 $2d$ 平面一组基</p><p>也就是一个二维线性变换可以仅由 $4$ 个数字确定，即变换后 $\hat{i}$ 的向量和 $\hat{j}$ 的向量</p><h1>将他们写成矩阵<br>$$<br>\begin{bmatrix}<br>a&amp;b\<br>c&amp;d<br>\end{bmatrix}<br>\<br>其中<br>\begin{bmatrix}<br>a\<br>c<br>\end{bmatrix}<br>是变换后的 \hat{i}<br>，<br>\begin{bmatrix}<br>b\<br>d<br>\end{bmatrix}<br>是变换后的 \hat{j}<br>$$<br>线性变换对矩阵的作用就直接按照矩阵乘法乘起来就好了<br>$$<br>所以对于向量<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>的变换就是<br>\<br>\begin{bmatrix}<br>a&amp;b\<br>c&amp;d<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}</h1><h1>x<br>\begin{bmatrix}<br>a\<br>c<br>\end{bmatrix}<br>+<br>y<br>\begin{bmatrix}<br>b\<br>d<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>ax+by\<br>cx+dy<br>\end{bmatrix}<br>$$</p><h3 id="矩阵乘法与线性变换复合">矩阵乘法与线性变换复合</h3><p>假设我要进行两个线性变换，这玩意叫“复合变换”</p><p>假设现在做两个线性变换<br>$$<br>\begin{bmatrix}<br>a&amp;b \<br>c&amp;d<br>\end{bmatrix}<br>\begin{bmatrix}<br>e&amp;f\<br>g&amp;h<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>$$</p><p>$$<br>你是先将<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>乘上<br>\begin{bmatrix}<br>e&amp;f\<br>g&amp;h<br>\end{bmatrix}<br>然后再乘上<br>\begin{bmatrix}<br>a&amp;b \<br>c&amp;d<br>\end{bmatrix}<br>$$</p><p>这是因为函数 $f(g(x))$ 这类的也是先看里面，道理相似</p><p>为什么矩乘没有交换律：</p><p>代数就不证了，<s>懒得写</s></p><p>可以画个图看看嘛<s>反正不是我画的</s>：</p><p>先<a href="https://baike.baidu.com/item/%E5%89%AA%E5%88%87%E5%8F%98%E6%8D%A2">剪切</a>后逆时针 $90^{\circ}$</p><p><img src="https://sjzezoj.com/image_hosting/wu2te7lxgf.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/39vmpndj82.png" alt=""></p><p>先逆时针旋转 $90^{\circ}$ 后剪切</p><p><img src="https://sjzezoj.com/image_hosting/hn9xgw7oi4.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/hu44rw1j3y.png" alt=""></p><p>寄！</p><p>为什么矩阵乘法有交换律：</p><p>你考虑</p><p>$ABC$ 和 $(AB)C$ ，从右往左读没有任何区别</p><p>所以就证完了（雾</p><h3 id="行列式">行列式</h3><p>在进行线性变换时改变面积的比例被称为这个线性变换的行列式</p><p>比如：</p><p><img src="https://sjzezoj.com/image_hosting/uz1c0vcbw7.png" alt=""></p><p>变换到</p><p><img src="https://sjzezoj.com/image_hosting/1vz6d1yo59.png" alt=""></p><p>这个线性变换的行列式就是 $2$</p><p>如果这个线性变换将原来的空间缩小了，则行列式为 $0$ ，比如将一个二维平面压成一条直线</p><p>如果空间定向发生了改变，则行列式为负</p><p>什么是定向？</p><p>就比如二维平面，可以将二维平面看成一张纸，将纸的正反面改变，定向就发生了改变，在二维平面中，一开始 $\hat{j}$ 在 $\hat{i}$ 的逆时针方向，如果在进行变换后到了 $\hat{i}$ 的顺时针方向，就等于定向发生改变</p><p><img src="https://sjzezoj.com/image_hosting/x3pzrtibtg.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/vxgwtp37v4.png" alt=""></p><p>这个线性变换的行列式就是 $-3$ （图好像寄了）</p><p>为什么空间定向变化后行列式为负？</p><p>考虑随着 $\hat{i}$ 和 $\hat{j}$ 靠近时面积的变化比例，他会慢慢接近于 $0$ ，当 $\hat{i}$ 与 $\hat{j}$ 重合时行列式为 $0$ ，所以继续走下去行列式为负数就变得合理了</p><p>但是上面所说的都是在二维空间下，那么三维呢</p><p>也是缩放的比例，不过变成了缩放体积的比例</p><p>那么三维空间中行列式为负怎么判断呀</p><p>有一个右手定则</p><p><img src="https://sjzezoj.com/image_hosting/z51fw73cce.png" alt=""></p><p>如果 $\hat{i},\hat{j},\hat{k}$ 能和手这样匹配上行列式就为正，否则为负</p><p>怎么计算行列式？<img src="http://%E5%9B%BE.tk/3" alt=""><img src="http://%E5%9B%BE.tk/3" alt=""><img src="http://%E5%9B%BE.tk/3" alt=""><br>$$<br>对于一个 2 \times 2 的矩阵<br>\begin{bmatrix}<br>a&amp;b \<br>c&amp;d<br>\end{bmatrix}<br>他的行列式<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a&amp;b \<br>c&amp;d<br>\end{bmatrix}<br>\end{pmatrix}<br>=ad-bc<br>$$<br>大概理解一下的话就是先假设 $b,c$ 都为 $0$ ， $a,d$ 就是表示 $\hat{i},\hat{j}$ 的缩放面积，当 $b,c$ 有一项不为 $0$ 时这是一个平行四边形，面积还是 $ad$ ，但是要是两个都不为 $0$ ， $bc$ 项会告诉你平行四边形在对角方向上变化了多少</p><p>具体的证明就是这个</p><p><img src="https://sjzezoj.com/image_hosting/wvn6qyug0y.png" alt=""></p><h1>那么三阶行列式呢<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a&amp;b&amp;c \<br>d&amp;e&amp;f \<br>g&amp;h&amp;i<br>\end{bmatrix}<br>\end{pmatrix}</h1><p>a<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>e&amp;f \<br>h&amp;i<br>\end{bmatrix}<br>\end{pmatrix}<br>-b<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>d&amp;f \<br>g&amp;i<br>\end{bmatrix}<br>\end{pmatrix}<br>+c<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>d&amp;e \<br>g&amp;h<br>\end{bmatrix}<br>\end{pmatrix}<br>$$<br><s>但是这些在 $OI$ 中好像都没有用</s></p><p>所以 $n$ 阶行列式怎么求值呢？<img src="http://%E5%9B%BE.tk/r" alt=""><img src="http://%E5%9B%BE.tk/r" alt=""><img src="http://%E5%9B%BE.tk/r" alt=""></p><p>设 $A$ 为一个 $n$ 维空间中的变换</p><p>$\det(A)=\sum\limits_p (-1)^{\tau(p)}\prod\limits_{i=1}^n A_{i,p_i}$ 其中 $p$ 是一个排列，$\tau(p)$ 是 $p$ 的逆序对数，这样直接算是 $O(n!\ n\log n)$</p><p>一些定义：</p><ul><li>当 $2 \not\mid \tau(p)$ 为奇排列，否则为偶排列</li><li>将一个排列交换两个元素位置被称为对换，发生一次对换后排列奇偶性发生改变（画一下就明白了）</li></ul><p>所以直接做直接寄，既然不能直接做，那么就肯定要找一些性质了</p><ol><li><p>交换 $A$ 的两行/列，行列式取反</p><p>证明：我们不考虑换$A$ ，考虑换 $p$ 的两个位置，这玩意等于就是在算 $\tau(p)$ 的时候不交换，但是在弄 $A_{i,p_i}$ 时交换，这显然是正确的，因为一次对换后奇偶性发生改变，所以时相反数</p></li><li><h1>$A$ 的行/列所有元素等比例变化，则行列式也等比例变化（这是显然的）<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>k\times a_{x,1}&amp;k\times a_{x,2}&amp;\cdots&amp;k\times a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}</h1><p>k\times<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>$$</p></li><li><h1>如果矩阵 $A$ 中有一行/列，是对应 $2$ 个矩阵 $B,C$ 中分别的 $2$ 相同位置的行/列所有元素之和。那么有 $\det(A)=\det(B)+\det©$ （也是显然的）<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>b_{x,1}+c_{x,1}&amp;b_{x,2}+c_{x,2}&amp;\cdots&amp;b_{x,n}+c_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}</h1><p>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>b_{x,1}&amp;b_{x,2}&amp;\cdots&amp;b_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>+<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>c_{x,1}&amp;c_{x,2}&amp;\cdots&amp;c_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>$$</p></li><li><p>如果 $A$ 存在两行/列成比例则 $\det(A)=0$<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>k\times a_{x,1}&amp;k\times a_{x,2}&amp;\cdots&amp;k\times a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>=0<br>$$<br>证明：对于排列 $p$ 做一个第 $x$ 行和第 $y$ 行的变换，发现行列式互为相反数，所以为 $0$ ，列同理</p></li><li><h1>把 $A$ 的一行/列的值全部乘一个常数加到另一行/列上，行列式值不变<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{y,1}&amp;a_{y,2}&amp;\cdots&amp;a_{y,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}</h1><h1>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>k\times a_{x,1}+a_{y,1}&amp;k\times a_{x,2}+a_{y,2}&amp;\cdots&amp;k\times a_{x,n}+a_{y,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>$$<br>证明：将后面那个矩阵用性质 $3$ 拆开，有<br>$$<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{y,1}&amp;a_{y,2}&amp;\cdots&amp;a_{y,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}</h1><p>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{y,1}&amp;a_{y,2}&amp;\cdots&amp;a_{y,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>+<br>\det<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n} \<br>a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{x,1}&amp;a_{x,2}&amp;\cdots&amp;a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>k\times a_{x,1}&amp;k\times a_{x,2}&amp;\cdots&amp;k\times a_{x,n} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>a_{n-1,1}&amp;a_{n-1,2}&amp;\cdots&amp;a_{n-1,n} \<br>a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n} \<br>\end{bmatrix}<br>\end{pmatrix}<br>$$<br>由性质 $4$ 可得，最后那个矩阵的行列式为 $0$</p></li></ol><p>有了这些性质就可以快速求行列式了 😍😍😍</p><p>发现要是矩阵中要是有一项 $A_{x,y}$ 为 $0$ 的话，对行列式的改变其实时很大的，所有 $p_x=y$ 的都不用算了，快算行列式的方法就是通过上面所说的一些性质变化出来 $0$</p><p>发现上面所有的变换跟高斯消元巨像，所以就直接高斯消元就好了，发现最后一定会消成一个上三角矩阵，所以排列 $p$ 就只有唯一一种取法了，时间复杂度 $O(n^3)$</p><p><a href="https://www.luogu.com.cn/problem/P7112">P7112 【模板】行列式求值</a></p><p>这道题很傻逼，模数不一定是质数，所以现在没有除法操作了 😡😡😡 ，那怎么办呢，发现好像可以辗转相减，对于 $a,b$ 要是 $a&gt;b$ 就让 $a$ 减去 $b$ ，否则 $b$ 减去 $a$ ，不难发现这样最后 $b$ 一定会变成 $0$ 的。</p><p>但是这样是 $O(n^3\log n)$ 的， $n=600$ 直接寄，怎么办呢？你发现每次辗转相减两次 $A_{i,i}$ 是会缩小为原来的 $\frac{1}{2}$ 的，所以只会辗转相减 $O(n\log n)$ 次，每次 $O(n)$ ，时间复杂度 $O(n^3+n^2\log n)$</p><p><a href="www.shukuang.com">code</a></p><h3 id="逆矩阵，列空间，零空间">逆矩阵，列空间，零空间</h3><p><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84?fromModule=lemma_search-box">线性方程组</a>可以通过矩阵来表示</p><h1>例如：<br>$$<br>2x+5y+3z=-3 \<br>4x+0y+8z=0 \<br>1x+3y+0z=2<br>$$<br>可以写成<br>$$<br>\begin{bmatrix}<br>2&amp;5&amp;3 \<br>4&amp;0&amp;8 \<br>1&amp;3&amp;0<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>z<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>3 \<br>0 \<br>2<br>\end{bmatrix}<br>$$<br>现在我们就等于要寻找一个向量 $\vec{v}$ 变换后与 $\vec{w}$ 重合</p><p>假设现在你有一个方程 $A\vec{v}=\vec{w}$</p><p>当行列式不为 $0$ 时</p><p>可以通过一个逆向操作的变换将 $\vec{w}$ 变成 $\vec{v}$</p><p>这个逆向操作的变换被称为 $A$ 的逆，记为 $A^{-1}$</p><p>$A^{-1}$ 的核心性质在于他乘上 $A$ 等于什么也没有干，这个被称为恒等变换</p><p>当求完逆后,就有</p><p>$A^{-1}A\vec{v}=A^{-1}\vec{w}$</p><p>$\vec{v}=A^{-1}\vec{w}$</p><p>当行列式不为 $0$ 时一定有逆变换</p><p>当行列式为 $0$ 时就没有逆变换了，但是不一定无解，如果答案正好在压成的空间上也是有解的</p><p>拿三维空间举例，显然变换成一个平面比变换成一条直线更容易有解，所以就有了新的定义<strong>秩</strong>，变换后时几位空间变换的秩就是几</p><p>变换后是所有能输出的向量的集合被称为矩阵的<strong>列空间</strong>，也就是 ${A\vec{v}}$ ，为什么叫列空间呢？因为这是把矩阵每一列拉出来当成向量构成的张成空间，所以更精确的秩的定义是列空间的维数</p><p>当秩达到最大值时，意味着秩和列数相同，这个被称为<strong>满秩</strong><br>$$<br>\begin{bmatrix}<br>0 \<br>0<br>\end{bmatrix}<br>一定在列空间里，因为线性变换原点不变<br>$$<br>对于一个满秩变换来说，零向量是唯一变换后还在本身的</p><p>遂于一个非满秩变换来说，会有一定向量在变换后变为零向量，变换后落在原点的向量集合被称为矩阵的**“零空间”或“核”**</p><h4 id="矩阵求逆">矩阵求逆</h4><p>因为是学 $OI$ 的，所以还是要学怎么求 😔😔😔</p><p>不过还好很简单！</p><p>已知 $A\times A^{-1}=I$</p><p>那么我们让 $A$ 和一个单位矩阵拼起来，拼成 $[AI]$</p><p>现在让他乘就是 $A^{-1}\times [AI]=[IA^{-1}]$</p><p>所以把 $[AI]$ 的左边消成单位矩阵，用高斯消元即可</p><h3 id="非方阵">非方阵</h3><p>非方阵是什么呢？一个 $n\times m$ 的矩阵可以理解为将 $m$ 维空间中的向量转换为 $n$ 维空间的向量</p><h3 id="点积与对偶性">点积与对偶性</h3><p>点积<br>$$<br>\begin{bmatrix}<br>a_1 \<br>a_2 \<br>a_3 \<br>… \<br>b_{n-1} \<br>a_n \<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 \<br>b_2 \<br>b_3 \<br>… \<br>b_{n-1} \<br>b_n \<br>\end{bmatrix}<br>=\sum\limits_{i=1}^{n} a_i\times b_i<br>$$<br>在二维平面中，这个玩意同样等于 $\vec{v}\vec{w}\cos\alpha$ ，其中 $\alpha$ 是 $\vec{v}$ 和 $\vec{w}$ 的夹角</p><p>为什么点积与顺序无关？</p><p>直观来讲，首先如果向量长度相同，发现对称，这是一样的</p><p><img src="https://sjzezoj.com/image_hosting/kntj0is40s.png" alt=""></p><p>现在将 $\vec{v}$ 缩放为 $k\vec{v}$，就没有对称性了 😔</p><p>但是可以这样想，如果是将 $\vec{w}$ 投影到 $k\vec{v}$ 上，$\vec{w}$ 的投影长度肯定是不变的，所以是 $k\vec{v}\vec{w}$</p><p>要是将 $k\vec{v}$ 投影到 $\vec{w}$ 上，等于是投影长度伸长了 $k$ 倍，所以也是 $k\vec{v}\vec{w}$</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流相关</title>
    <link href="/2023/08/15/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/08/15/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="最大流">最大流</h3><h4 id="无源汇上下界最大流">无源汇上下界最大流</h4><p>设第 $i$ 条边的流量需要在 $[l_i,r_i]$ 中首先考虑将每条边加上流量 $l_i$，现在边权限制就是 $[0,r_i-l_i]$，但是这样流量就不守恒了，寄。</p><p>考虑怎么让流量守恒，建立超级源汇点，设现在每个点入流量为 $in_i$，出流量为 $out_i$，如果 $in_i&gt;out_i$，那么就让超级源点向点 $i$ 连一条流量为 $in_i-out_i$ 的边，如果 $out_i&gt;in_i$，那么就让点 $i$ 向超级汇点连一条流量为 $out_i-in_i$ 的边，这样流量就守恒了，设超级源点向外面连接的边的流量和为 $sum$，如果最大流等于 $sum$ 则说明有可行流，反之没有。</p><p>我太菜了不会证明，网上搜到的也看不懂/ng，感性理解一下就是对于一个点 $x$，如果是入流量大于出流量，现在我图上这个点之流出去了 $out_i$，还少 $in_i-out_i$，我们通过超级源点补上，入流量小于出流量同理。我们从超级源点流向超级汇点的一条路径就相当于给这些边加上这些流量，使得在原图（不加源汇）上流量平衡。</p><h4 id="有源汇上下界可行流">有源汇上下界可行流</h4><p>跟上面基本一样，发现上面我们的做法需要让所有点流量守恒，但是现在源点汇点流量不守恒，但是因为源点流出的和汇点流入的肯定一样，所以我们加一条 $(T,S)$，边权限制是 $[0,INF]$ 的边就好了。</p><h4 id="有源汇上下界最大流">有源汇上下界最大流</h4><p>发现我们在”有源汇上下界可行流“中加入的新边的流量就是从 $S$ 到 $T$ 的可行流流量，这个不一定是最大的，我们直接在残量网络上再跑一遍最大流就好了，这里需要把我们所有加的点和边全部删掉，不难发现是正确的。</p><h4 id="有源汇上下界最小流">有源汇上下界最小流</h4><p>根据”有源汇上下界最大流“的启发，我们可以在残量网络上做一些东西来达到我们的目的，所以最小流就是可行流流量减去从 $T$ 到 $S$ 的最大流。</p><h3 id="最小割">最小割</h3><h4 id="最小割的构造方案">最小割的构造方案</h4><p>从源点出发只走没有满流的边，将这些点标记，如果一条边的 $s$ 被标记了并且 $t$ 没有被标记，那么这条边就是割边。</p><p>证明：跑完最小割后源点和汇点在残量网络上是不连通的，我们标记的点全是在残量网络上和源点连通的点，割边就显然是这些了。</p><h4 id="最小割的可行边与必须边">最小割的可行边与必须边</h4><p>在残量网络上面缩点，不难发现如果一条边的起点 $s$ 和终点 $t$ 在同一个强连通分量里面一定不会成为割边，因为一定有另一条从 $s$ 到 $t$ 的边，我把流量换到这边就行了。</p><p>如果一条边的 $s$ 和 $t$ 不在一个强连通分量里面则有可能成为割边（如果有流量到达 $s$ 时需要割掉，但是也有可能在前面已经割掉过一些边使得不可能有流量到这里），考虑什么边是必须割掉的，不难发现一定是直接从源点的强连通分量连到汇点的强连通分量的边（因为不可能通过割掉一些边使流量到不了 $s$）。</p><h3 id="套路">套路</h3><h4 id="最大权闭合子图">最大权闭合子图</h4><blockquote><p>定义一个有向图 $G(V,E)$ 的闭合子图 $V’$ 为：若 $(u,v)\in E$ 并且 $u \in V’$，则 $v \in V’$，对每个点定义一个权值 $val_i$，定义有向图 $G(V,E)$ 的闭合子图 $V’$ 的权值为 $\sum\limits_{u \in V’}val_u$，现在给定一张有向图，求他的最大权闭合子图。</p></blockquote><p>首先有一个 naive 的想法就是将所有权值大于 $0$ 的点全部选上，但是发现有可能这些正权点后面有很多负权点，导致选了还亏了，然后就寄了，现在考虑通过网络流建图修正这个东西。</p><p>发现我们现在是要删点，考虑从最小割入手，一个天降的思路就是我们建出超级源汇，让源点向所有的 $val&gt;0$ 的点 $u$ 建一条 $(S,u,val_u)$ 的边，这样割掉一条这样的边就等于不选这个点了，发现还有可能是我们正权点的贡献将所有他们到达的负权点贡献抵消了，也就是把负权点也选上，⚪来我们图只建了一半，现在就正好把另一半补上了，对于所有的 $val \le 0$ 的点 $u$ 我们建一条 $(u,T,-val_u)$ 的边，这样割掉这样的边就等于选上这个负权点，将负权点和正权点用原图连接，因为不能割原图的点，所以边权设为 $INF$，这样就做完了，最后答案为 $\sum\limits_{u\in G}[val_u&gt;0]val_u-flow$ ，其中 $flow$ 就是最小割，根据上面的推断，不难输出方案。</p><h4 id="联通块">联通块</h4><blockquote><p>给出 $k$ 棵树，每棵树有 $n$ 个点，给定每个数的权值 $A$，求一个权值和最大的数的集合，使得它在 $k$ 棵树上都是连通块</p><p>$n\le 50000$</p></blockquote><p>假设固定一个根节点，那么就等于我如果选 $i$，那么就需要将 $i$ 在所有树上的父亲都选上，这玩意就是一个最大权闭合子图，但是现在不固定根节点，考虑对第一棵树进行点分治，将重心作为必须选的点，根据主定理这样复杂度不变。</p><h4 id="无名氏1">无名氏1</h4><blockquote><p>给出一张有向图，每条边容量为 $1$，每个点有一个权值 $c_i$，要求选一个边的子集，使得 $\max\limits_{u\in V}|c_u-out_u+in_u|$ 最小，其中 $in_i,out_i$ 分别代表点 $i$ 的入度出度。</p><p>$n,m\le 1000$</p></blockquote><p>首先最大值最小考虑二分，现在我们知道答案上界 $x$，假设入度为，那么出度范围就是 $[max(0,in_u+c_u-x),in_u+c_u+x]$（就是列不等式然后拆开），建出超级源汇，对于出度不为 $0$ 的点连前面范围的流量，对于出度为 $0$ 的点也连一个类似的东西，跑上下界网络流就好了。</p><h4 id="洛谷-P4313-文理分科"><a href="https://www.luogu.com.cn/problem/P4313">洛谷 P4313 文理分科</a></h4><p>考虑最小割，考虑算出不需要的权值，然后用所有的减去，对于同学 $(i,j)$ 让源点向他连一条 $art_{i,j}$ 的边，割掉这条边表示让这个同学选理科，然后让他向汇点连一条 $science_{i,j}$ 的边，割掉表示让这个同学选文科。</p><p>现在还有和周围选的分科相同的没有处理，对于每个同学 $(i,j)$ 新建点， 让所有与 $(i,j)$ 相邻的点向他连一条边权为 $+\infty$ 的边，然后这个点再向汇点连一条边权为 $sam_science_{i,j}$ 的边，这样如果我割掉的全是文科那么我肯定不会流过来，不用割掉，否则必须割掉，和原问题等价，相同的选文科的同理。</p><h4 id="S2OJ-1810-【2017-3-长乐省选集训-Day5-T3】炮塔"><a href="https://sjzezoj.com/problem/1810">S2OJ #1810. 【2017.3 长乐省选集训 Day5 T3】炮塔</a></h4><p>数据范围很小，考虑一种非常暴力的方法，我们对于一个炮塔都建一排点，表示这个炮塔打了多远（这个点前面的边权表示打了多少人），发现限制不好解决，考虑从最小割入手，发现这玩意建出来的图跟<a href="https://www.luogu.com.cn/problem/P3227">切糕</a>很像，跟这个题一样，考虑假设炮塔 $x,y$ 互相影响，如果 $x$ 攻击距离为 $len_x$ 时 $y$ 攻击距离要小于等于 $len_y$，让 $len_y$ 对应的点向 $len_x$ 对应的点连一条边权为 $+\infty$ 的边，发现我要是炮塔 $y$ 的距离大于 $len_y$ 则并没有割掉任何东西，所以只能选 $len_y$ 之前的点。</p><p><s>这玩意是真jb难写</s></p><h4 id="无名氏2">无名氏2</h4><blockquote><p>给出一张混合图（即有有向边也有无向边的图），你需要给每一条无向边定向，使得定向后的图存在欧拉回路。</p><p>$n \le 10000,m \le 30000$</p></blockquote><p>发现这玩意跟无源汇上下界可行流处理完第一步之后很像，就是要实现流量平衡，直接跟无源汇上下界可行流处理方法一样就好了。</p><h4 id="DAG-旅游">$DAG$ 旅游</h4><blockquote><p>给定一张 $DAG$，一个人从 $S$ 出发开始旅游</p><p>如果当前点有出边，就等概率选一条出去，否则结束旅游</p><p>现在我可以在满足 $k$ 个形如 $(x,y,z)$ 的限制的情况下删掉一些边，使得旅游经过的期望边数最大。</p><p>限制 $(x,y,z)$ 表示如果删掉 $(x,y)$，那么 $(x,z)$ 也需要被删掉。</p><p>$n\le 50,m\le 500,k \le 2000$</p></blockquote><h4 id="S2OJ-1422-Floodfill"><a href="https://sjzezoj.com/problem/1422">S2OJ #1422. Floodfill</a></h4><blockquote><p>给出两张 $n\times m$ 的黑白图像 $A,B$，可以操作无限次，每次操作翻转 $A$ 里面的一个极大的同色连通块，求操作若干次后 $A$ 和 $B$ 最少的不同色位置数量。</p><p>$n,m\le 100$</p></blockquote><p>首先肯定对于一个点我只会操作一次（废话），发现我操作后就和原来旁边的同色连通块颜色相同了，相当于合并了，现在就不能翻转周围的连通块了，因为这样会连带操作当前连通块，所以等于就是我操作的所有极大连通块是一个独立集（把相邻看成连边的图），现在将问题简化成：给定一张二分图，对于一个点，若不操作则贡献为 $a_i$，若操作则贡献为 $b_i$，现在选出一个操作的点集 $S$，要求 $S$ 是一个独立集，求每个点权值和最大是多少。考虑网络流建图，对于一个白点 $u$ 连 $(S,u,b_i),(u,T,a_i)$ ，对于一个黑点 $u$ 连 $(S,u,a_i),(u,T,b_i)$，对于一个在原图上的一条边 $(u,v)$，设 $u$ 为白点，连 $(u,v,INF)$，从最小割考虑，割掉的为不选的，如果白点<strong>割掉</strong>的是操作，则黑点什么都行，否则黑点只能是不操作，而黑点对白点没有限制，因为可以两个都不操作，所以建图是正确的。</p><p><a href="https://sjzezoj.com/submission/77437">code</a></p><h4 id="“弯人”">“弯人”</h4><p><s>我是直的</s></p><h4 id="DeerInZooDivOne">DeerInZooDivOne</h4><blockquote><p>在树上选择两个尽量大的不相交的同构的连通块</p><p>$n \le 50$</p></blockquote><h4 id="CF739E-Gosha-is-hunting"><a href="https://www.luogu.com.cn/problem/CF739E">CF739E Gosha is hunting</a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望</title>
    <link href="/2023/08/15/%E6%9C%9F%E6%9C%9B/"/>
    <url>/2023/08/15/%E6%9C%9F%E6%9C%9B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp5.toutiaoimg.com%2Flarge%2F5da00080b05131e27b6&amp;refer=http%3A%2F%2Fp5.toutiaoimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1669088490&amp;t=52c1e094d5d4865251cd272696b4a7d8" alt=""></p><h2 id="期望">期望</h2><p>好像没有什么知识点呀 😅</p><p>满足可加性 $E(ax+by)=aE(x)+bE(y)$</p><p>当事件 $x,y$ 相互独立时满足可乘行 $E(x\times y)=E(x)\times E(y)$</p><h4 id="n-个相互独立取值在-0-1-的随机变量，其中第-k-小的随机变量的值的期望">$n$ 个相互独立取值在 $[0,1]$ 的随机变量，其中第 $k$ 小的随机变量的值的期望</h4><p>考虑引入一个新随机变量 $n+1$ ，发现第 $k$ 小的随机变量的值期望等于新点在第 $k$ 小变量前面的概率</p><p>因为是连续随机变量，分布是均匀的，所以可以抽象成排列来考虑，将随机变量看成隔板，现在隔板将 $[0,1]$ 均匀分成 $n+1$ 份，而 $k$ 前面有 $k$ 份，所以第 $k$ 小的随机变量的值的期望是 $\frac{k}{n+1}$</p><h3 id="典-其实下面也有好多典题-😅">典 <s>其实下面也有好多典题 😅</s></h3><h4 id="P4316-绿豆蛙的归宿"><a href="https://www.luogu.com.cn/problem/P4316">P4316 绿豆蛙的归宿</a></h4><p>题意：求 $dag$ 上从 $S$ 走到 $T$ 的期望步数</p><p>倒推：设 $f_u$ 表示从 $u$ 走到 $T$ 的期望步数，转移是 $f_u=\sum\limits_{v}^{(u,v) \in E} \frac{(f_v+w)}{deg_u}$ 其中 $deg$ 是出度</p><p>正推：设 $f_u$ 表示从 $S$ 走到 $u$ 的期望步数，转移是 $f_v=\sum\limits_{u}^{(u,v) \in E} \frac{(f_u+g_u \times w)}{deg_u},g_u=\sum\limits_{u}^{(u,v) \in E} \frac{g_u}{deg_u}$</p><p>倒着推很没意思，但是正着推感觉好怪，但是仔细想想是对的，因为我不一定走 $(u,v)$ 这条边，等于就是 $E(a+bx)$ 中的 $x$ ，但是为啥倒推是对的呀 🤔，因为从 $u$ 出发必定要走一条出边，所以概率和为一，也就是 $x=\frac{w}{deg}$ 了</p><p>正推：<a href="https://www.luogu.com.cn/record/109981628">code</a></p><h3 id="我不会做部分">我不会做部分</h3><h4 id="CF235B-Let’s-Play-Osu"><a href="https://www.luogu.com.cn/problem/CF235B">CF235B Let’s Play Osu!</a></h4><p>二次期望</p><p>我们现在想求 $E(x^2)$ 不会，嘿嘿 🤭</p><p>假设现在连续 $O$ 长度为 $x$ ，我们加上一个 $O$ 的贡献是  $E((x+1)^2)-E(x^2)=E(x^2)+E(1)+E(2x)-E(x^2)=E(2x+1)$</p><p>现在我们需要知道 $E(x)$ ，容易发现 $E(x)=(E(x-1)+1)\times p_i$</p><h4 id="P1654-OSU"><a href="https://www.luogu.com.cn/problem/P1654">P1654 OSU!</a></h4><p>和上面差不多</p><h4 id="P1850-NOIP2016-提高组-换教室"><a href="https://www.luogu.com.cn/problem/P1850">P1850 [NOIP2016 提高组] 换教室</a></h4><p>设 $f_{i,j,0/1}$ 表示我现在上到第 $i$ 节课，用了 $j$ 次换教室机会，现在在 $c_i/d_i$ 的期望步数，直接 $dp$ 即可</p><p><s>代码我已经看不懂了</s></p><h4 id="P2473-SCOI2008-奖励关"><a href="https://www.luogu.com.cn/problem/P2473">P2473 [SCOI2008] 奖励关</a></h4><p>🕊🕊🕊</p><h4 id="P6835-Cnoi2020-线形生物"><a href="https://www.luogu.com.cn/problem/P6835">P6835 [Cnoi2020]线形生物</a></h4><p>简单题 💧💧💧</p><p>不想写了看题解去吧</p><h4 id="P4206-NOI2005-聪聪与可可"><a href="https://www.luogu.com.cn/problem/P4206">P4206 [NOI2005] 聪聪与可可</a></h4><p>🕊🕊🕊</p><h4 id="CF280C-Game-on-Tree"><a href="https://www.luogu.com.cn/problem/CF280C">CF280C Game on Tree</a></h4><p>考虑 $dp$ ，发现根本不会做🤡</p><p>那就把每个点根据期望的线性性拆开</p><p>设现在的点是 $u$ ，$u$ 有 $x$ 个祖先，将操作看成序列，发现 $u$ 会有贡献当且仅当所有祖先都在我后面，所以期望贡献是 $\frac{1}{dep_u}$ ，这玩意我想了一年 👈🤣</p><h4 id="2544-「JXOI2018」游戏"><a href="https://loj.ac/p/2544">#2544. 「JXOI2018」游戏</a></h4><p>🧐🧐🧐</p><p>感觉和上面的很像，只用检查所有区间内没有约数的数就可以了</p><p>然后这个题还有一个好玩的东西</p><p>现在有 $n$ 个球，求随便选出 $k$ 个关键球，最后一个点位置的期望</p><p>我现在要算最后一个关键球位置等于 $n-\text{球在所有关键球后面的个数}$</p><p>先不考虑球的标号，假设现在已经选出所有关键球，现在就等于有 $k+1$ 个抽屉，等概率放球，所以在所有关键球后面的概率是 $\frac{1}{k+1}$ ，那么在所有关键球后面球的期望是 $\frac{n-k}{k+1}$ ，那么最后一个关键球位置期望就是 $n-\frac{n-k}{k+1}=\frac{(n+1)k}{k+1}$</p><p>所以答案乘上 $n!$ 就对了</p><h4 id="P3750-六省联考-2017-分手是祝愿"><a href="https://www.luogu.com.cn/problem/P3750">P3750 [六省联考 2017] 分手是祝愿</a></h4><p>有一半的分是 $k=n$ 😍</p><p>首先先想一个贪心看看怎么做</p><p>从后往前考虑，如果他的倍数有奇数个要操作那么就为 $1$ ，否则为 $0$</p><p>不难发现一定是优的</p><p>想到这个 $100$ 分就很简单了</p><p>设 $f_i$ 表示还需要操作 $i$ 个灯，这时我想减去一个灯的期望次数，转移方程显然 $f_i=1+(n-i)\times(f_{i+1}+f_i)$ ，就是如果我这次操作没有成功会多一个灯需要操作，然后从 $i+1$ 个操作到 $i-1$ ，然后化简一下柿子就好了</p><h4 id="P4284-SHOI2014-概率充电器"><a href="https://www.luogu.com.cn/problem/P4284">P4284 [SHOI2014] 概率充电器</a></h4><p>不会做👈🤣</p><p>首先发现期望根本没用，求概率就可以了。</p><p>思考一个点怎么着会被充上电，一种是自己直接充上，还有就是从上面充上电或者从下面充上电</p><p>发现是一颗树，所以从下面充上电很好做，自己直接冲上也是很简单的，现在就考虑怎么算从上面来的就好了</p><p>假设我现在在点  $u$ 并且已经算好了，我现在要贡献到子节点 $v$ 这一个操作，现在我对 $v$ 的贡献是这个点充上电的概率 $-$ 只从 $v$ 上来 $u$ 充上电的概率，然后就推一下柿子</p><p>设 $(u,v)$ 出现概率为 $A$ ，$v$ 充上电概率为 $B$，$x$ 为不算 $v$ 的充电概率， $y$ 为算 $v$ 的充电概率</p><p>有柿子：</p><p>$y=(1-x)AB+x$</p><p>$y=AB+x-xAB$</p><p>$y=AB+x(1-AB)$</p><p>$x=\frac{y-AB}{1-AB}$</p><p>$y-x=y-\frac{y-AB}{1-AB}$</p><p>乘上点系数就做完了</p><h4 id="P3239-HNOI2015-亚瑟王"><a href="https://www.luogu.com.cn/problem/P3239">P3239 [HNOI2015]亚瑟王</a></h4><p>我就是亚瑟王！😎😎😎</p><p>一开始我设的是 $f_{i,j}$ 表示考虑在第 $j$ 轮，我现在考虑到了第 $i$ 个并且选他的概率，但是不对 😔</p><p>正确的是设 $f_{i,j}$ 表示 $r$ 轮一块考虑，现在考虑到第 $i$ 个数，有 $j$ 轮已经选数的方案数</p><p>那么我不选数的概率是 $(1-p_i)^{m-j}$ ，选的就是 $1-(1-p_i)^{m-j}$</p><p>但是好像不会统计答案，发现我转移时的东西就是选的概率，所以在转移的时候统计就可以了</p><h4 id="pjudge-21743-青鱼和怪兽"><a href="http://pjudge.ac/contest/1114/problem/21743">pjudge 21743 青鱼和怪兽</a></h4><p>🐟🐟🐟</p><p>设 $f_{i,j}$ 表示玩家还有 $i$ 点血量，👾还有 $j$ 点血量时获胜的期望时间</p><p>转移方程：$f_{i,j}=\min(f_{n,m},1+p\times f_{i,j-1}+(1-p)\times f_{i-1,j})$</p><p>发现这有个取 $\min$ ，根本不会做，我也不能实数枚举 😔，但是发现每次都是对一个数和 $f_{n,m}$ 取 $\min$ ，仔细思考 🤔 发现 $f_{n,m}$ 是具有单调性的，可以二分 🤩🤩🤩</p><p>具体来说，假设现在二分的 $f_{n,m}$ 是 $x$ ，如果按 $x$ 算出来的 $f_{n,m}$ 比 $x$ 小说明你 $x$ 设大了，缩小，否则增大</p><h4 id="6513-「雅礼集训-2018-Day10」足球大战"><a href="https://loj.ac/p/6513">#6513. 「雅礼集训 2018 Day10」足球大战</a></h4><p>⚽⚽⚽</p><p>发现这玩意能直接算</p><p>主队在 $n$ 秒内进 $m$ 个球的概率是 ${n\choose m}\times p^m\times (1-p)^{n-m}$ ，客队换成 $q$ 就行了</p><p>现在想主队赢，那么概率就是 $\sum\limits_{i=1}^{n}({n\choose i}\times p^i\times (1-p)^{n-i}\times (\sum\limits_{j=0}^{i-1}{n\choose j}\times q^j\times (1-q)^{n-j}))$</p><p>枚举主队进球数，对客队进球数那个 $\sum$ 做一个前缀和就好了</p><p>注意 $n$ 是 $1e7$ 级别的，不能快速幂，要预处理次方</p><h4 id="6495-「雅礼集训-2018-Day1」树"><a href="https://loj.ac/p/6495">#6495. 「雅礼集训 2018 Day1」树</a></h4><p><a href="https://noiresources.ccf.org.cn/NOI2022%E5%AE%A3%E4%BC%A0%E7%89%87.mp4"><s>倒悬的splay</s></a> （有端暗示</p><p>有一个经典技巧，发现不会期望，可以将答案按某些性质划分为一些类，然后对于每类计数</p><p>设 $f_{i,j}$ 表示现在树上有 $i$ 个点，最大深度为 $j$ 的方案数，考虑现在加入第 $i+1$ 个点怎么做</p><p>然后不会做👈🤣</p><p>🤔 一下发现好像就是不能转移，但是发现根节点性质很好，所以考虑加入的是根节点</p><p>发现 $2$ 号节点一定是连向 $1$ 号节点的，所以按这玩意分类</p><p>没有子节点：这就是初始化的值</p><p>有子节点：枚举 $2$ 号节点子树大小以及深度，然后枚举剩下的子树加上根节点组成的树的节点数和深度，拼一块就好了</p><p>注意转移顺序</p><p><s>所以这玩意是 $O(n^4)$ 的</s></p><h4 id="CF1187F-Expected-Square-Beauty"><a href="https://www.luogu.com.cn/problem/CF1187F">CF1187F Expected Square Beauty</a></h4><p>推柿子</p><p>首先求一下 $E(B(x))$ ，这玩意非常简单，就等于 $1+\sum\limits_{i=2}^{n}[x_{i-1}\not=x_i]$</p><p>然后平方一下： $E(B(x)^2)=E((1+\sum\limits_{i=2}^{n}[x_{i-1}\not=x_i])\times (1+\sum\limits_{i=2}^{n}[x_{i-1}\not=x_i]))$</p><p>化简：</p><p>$E(B(x)^2)=E(1+2\sum\limits_{i=2}^{n}[x_{i-1}\not=x_i]+\sum\limits_{i=2}^{n}[x_{i-1}\not=x_i]\sum\limits_{j=2}^{n}[x_{j-1}\not=x_j]$</p><p>发现第 $i$ 个 $[x_i\not=x_{i-1}]$ 之和第 $i-1,i,i+1$ 有关，把这些拿出来单独做，剩下的直接乘就好了</p><h4 id="AGC006C-Rabbit-Exercise"><a href="https://www.luogu.com.cn/problem/AT_agc006_c">[AGC006C] Rabbit Exercise</a></h4><p><s>这个性质我在初三考 NOIP 的时候场上想出来了，但是高一做这道题的时候没想出来 👈🤣</s></p><p>第 $i$ 只兔子跳完位置的期望是 $\frac{2\times a_{i-1}-a_i+2\times a_{i+1}-a_i}{2}=a_{i+1}+a_{i-1}$</p><p>这玩意不就是 $NOIP2021$ 方差嘛！那就差分一下，然后现在第 $i$ 只兔子跳等于 $swap(a_i,a_{i+1})$</p><p>然后这个万一就可以倍增了/hanx</p><h4 id="2325-「清华集训-2017」小-Y-和恐怖的奴隶主"><a href="https://loj.ac/p/2325">#2325. 「清华集训 2017」小 Y 和恐怖的奴隶主</a></h4><p>首先先列出 $dp$ ：$f_{i,a,b,c}$ 表示进行了 $i$ 轮，有 $a$ 个 $1$ 滴血的👾，有 $b$ 个 $2$ 滴血的👾，有 $c$ 个 $3$ 滴血的👾的期望，转移很简单，但是有点长，不想写了开摆，答案就是打怪兽时转移转移的概率</p><p>每一层的转移都是一样的，并且发现状态数不是很多，考虑用矩阵优化 $dp$ ，现在时间复杂度是 $Tstate^3\log n$ 这个有点大，过不去，但是因为矩阵乘向量是 $O(n^2)$ ，可以预处理出所有 $2^i$ 的矩阵，直接拼起来求答案，时间复杂度 $O(state^3\log n+Tstate^2\log n)$</p><p>实测 $state$ 大小是 $165$ ，加上一个答案就是 $166$</p><h4 id="gym102978-H-Harsh-Comments"><a href="https://codeforces.com/gym/102978/problem/H">gym102978 H. Harsh Comments</a></h4><h4 id="CF643E-Bear-and-Destroying-Subtrees"><a href="https://www.luogu.com.cn/problem/CF643E">CF643E Bear and Destroying Subtrees</a></h4><p>无语了 👈🤣</p><p>首先考虑 $O(n^2)$ 的 $dp$ 怎么做</p><p>设 $f_{u,j}$ 表示以节点 $u$ 为根节点，树深度为 $j$ 的概率，但是发现这样转移要搞一个前缀和，不如直接把状态改为：以节点 $u$ 为根节点，树深度小于等于 $j$ 的概率，转移就很简单了 $f_{u,j}=\prod\limits_{v}^{(u,v)\in E} (\frac{f_{v,j-1}}{2}+\frac{1}{2})$</p><p>然后考虑优化，现在这个题牛逼的地方就来了，发现如果深度太深的话概率太小，不用计算，深度直接算到五六十就行了 😮</p><h4 id="CF908D-New-Year-and-Arbitrary-Arrangement"><a href="https://www.luogu.com.cn/problem/CF908D">CF908D New Year and Arbitrary Arrangement</a></h4><h4 id="CF1067D-Computer-Game"><a href="https://www.luogu.com.cn/problem/CF1067D">CF1067D Computer Game</a></h4><h4 id="AGC020F-Arcs-on-a-Circle"><a href="https://www.luogu.com.cn/problem/AT_agc020_f">[AGC020F] Arcs on a Circle</a></h4><h4 id="CF98E-Help-Shrek-and-Donkey"><a href="https://www.luogu.com.cn/problem/CF98E">CF98E Help Shrek and Donkey</a></h4><h3 id="瞎猜消元部分-text-Guess-elimination">瞎猜消元部分 ( $\text{Guess elimination}$ )</h3><h4 id="CF24D-Broken-robot"><a href="https://www.luogu.com.cn/problem/CF24D">CF24D Broken robot</a></h4><p>考虑对于每一行分开高斯消元</p><p><a href="https://www.luogu.com.cn/problem/T273265">$THUSC2022$ 解法</a></p><h4 id="P3232-HNOI2013-游走"><a href="https://www.luogu.com.cn/problem/P3232">P3232 [HNOI2013]游走</a></h4><p>随机游走板子</p><h4 id="PKUSC2022-D1T1-Rating"><a href="http://www.gdfzoj.com:23380/contest/757/problem/4017">[PKUSC2022] D1T1 Rating</a></h4><h3 id="坚定学校自信">坚定学校自信</h3><h4 id="1817-【2017-3-长乐省选集训-Day18-T3】子串"><a href="https://sjzezoj.com/problem/1817">#1817. 【2017.3 长乐省选集训 Day18 T3】子串</a></h4><p>建出字符集的 $AC$ 自动机，然后根据他所说的列方程高斯消元就好了</p><h4 id="1472-【2022-7-11】旅行-travel"><a href="https://sjzezoj.com/problem/1472">#1472. 【2022.7.11】旅行 travel</a></h4><p>首先每个点的权值很好算，搞树上差分就好了</p><p>然后是最简单的 $O(n^2)\ dp$  ，设 $f_i$ 表示一次方期望， $g_i$ 表示二次方期望做，发现只有根节点是对的，所以做 $n$ 遍就好了</p><p>考虑用换根优化，假设算出 $u$ 的贡献，现在要换到 $v$ ，现在 $u$ 对 $v$ 的贡献就是 $u$ 的贡献刨去子树 $v$ 乘上边权，发现好像合并上去了就不好刨出来了，所以在 $dp$ 记一个前后缀 $f,g$  值，这样就能刨出去了</p><h4 id="1454-【NOIP模拟（第二套）】B-数连通块"><a href="https://sjzezoj.com/problem/1454">#1454. 【NOIP模拟（第二套）】B. 数连通块</a></h4><p>两种方法：</p><p>第一种就是直接干，树上莫队求区间权值和</p><p>第二种是把一条边的权值离散到 $(u_i,v_i)$ 上二位数点</p><p><a href="https://www.luogu.com.cn/training/237150#problems">南校 期望 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F9399b942e3b58e4ef81170e52564cc7631b78102e385c-u5d1HF_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1669009243&amp;t=49374371256902e16a3c6e04bfe2e656" alt="您是神/bx,我是shabby/kk"></p>]]></content>
    
    
    
    <tags>
      
      <tag>期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面图对偶图</title>
    <link href="/2023/08/15/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%AF%B9%E5%81%B6%E5%9B%BE/"/>
    <url>/2023/08/15/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%AF%B9%E5%81%B6%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4vgtxrnv.png" alt=""></p><p>注意：博主并<strong>不会</strong>最小左转法！</p><h4 id="什么是平面图：">什么是平面图：</h4><p>如果能将一张图放到平面上并且边不相交，那么这张图就被称为平面图，比较常见的平面图就是网格图。</p><p>像这张图就是平面图：</p><p><img src="https://sjzezoj.com/image_hosting/v4ealecxl6.png" alt=""></p><p>但是这张图就不是平面图：</p><p><img src="https://sjzezoj.com/image_hosting/3vqnxrl90q.png" alt=""></p><p>这条红边放到外面也会和 $(1,4)$ 这条边相交。</p><h4 id="关于平面图的一些概念：">关于平面图的一些概念：</h4><ul><li>有限面：一张平面图将一个平面分成了很多个部分，面积是有限的部分被称为有限面。</li><li>无限面：同上，面积无限的部分被称为无限面。</li></ul><p><img src="https://sjzezoj.com/image_hosting/cd94pn75kp.png" alt=""></p><p>比如这张图，面 $2,3,4$ 都是有限面，而面 $1$ 是无限面。</p><ul><li>欧拉公式：$\text{点数}-\text{边数}+\text{面数}=2$。</li><li>常用性质：对于 $n \ge 3$ 的联通简单平面图，有 $m \le 3\cdot n-6$，其中 $n$ 是点数，$m$ 是边数。</li></ul><h4 id="什么是对偶图：">什么是对偶图：</h4><p>有源汇：将源点和汇点用另一条边链接，将每个面看成点，两个相邻的面连边，边权是邻边的权值。</p><p>比如这张图：（设源点为 $1$，汇点为 $5$）</p><p><img src="https://sjzezoj.com/image_hosting/rqehsznptu.png" alt=""></p><p>它的对偶图就是:</p><p><img src="https://sjzezoj.com/image_hosting/c89jp772m3.png" alt=""></p><p>新图中源点为 $1$，汇点为 $6$。（因为这里多加了一条红边，所以有可能加不了，然后就寄了，但是一般题目都是用网格图，所以没啥事）</p><p>对偶图有非常神奇的性质：将每一条从源点到汇点的路径对应着一个割，至于为什么，大概就是你将经过的边全部割掉，对偶图上 $S$ 和 $T$ 就连通了，说明除了我加的红边之外没有路径能从平面图上的 $S$ 到 $T$ 了。</p><p>根据这个性质我们就能优化一些东西。</p><p>无源汇：只要不加上面那张图的红边就好了，割就是一个经过无限面的环。</p><p>若图为有向图，不难发现原图上的边权对应的是逆时针旋转 $90^{\circ}$ 的边权，比如上面那张图，平面图上边 $(1,3)$ 对应的就是对偶图上的 $(4,6)$，而 $(3,1)$ 则是 $(6,4)$。</p><h3 id="例题：">例题：</h3><p><a href="https://www.luogu.com.cn/paste/cyelzqr5"><s>代码都在这里</s></a></p><h3 id="洛谷-P4001-ICPC-Beijing-2006-狼抓兔子"><a href="https://www.luogu.com.cn/problem/P4001">洛谷 P4001 [ICPC-Beijing 2006] 狼抓兔子</a></h3><p>这玩意就是一个最小割，但是直接流复杂度是 $O(n^6)$ 的<s>虽然能过，我谔谔</s>。</p><p>首先这个图显然是平面图，题目又是让求最小割，考虑转成对偶图，对偶图上从起点到终点每一条路径都是一个割，所以最小割就是最短路，然后跑最短路就没了。（</p><h3 id="洛谷-P3209-HNOI2010-平面图判定"><a href="https://www.luogu.com.cn/problem/P3209">洛谷 P3209 [HNOI2010] 平面图判定</a></h3><p>首先发现边有那么多根本没用，$m$ 大于 $3\cdot n-6$ 的直接输出 $NO$ 就好了。</p><p>将一条边拆成两个点，一个为这条边放到环内部，一个为这条边放到环外部，枚举两条边 $i,j$ ，若他们能放到同一侧就不连边，否则就将 $i$ 的放在环内部点和 $j$ 的放在环外部点连起来，将 $i$ 的放在环外部点和 $j$ 的放在环内部点连起来，因为边是无向边，所以直接并查集就好了，不用 $\text{2-sat}$（这个处理的是有向图）。</p><p>这样时间复杂度就是 $O(Tn^2)$ 的，可以通过，注意判相交的细节。</p><h3 id="洛谷-P2046-NOI2010-海拔"><a href="https://www.luogu.com.cn/problem/P2046">洛谷 P2046 [NOI2010] 海拔</a></h3><p>发现我走太高并不优，这样只会徒加贡献，所以每个点高度只可能是 $0,1$，思考一下发现高度为 $0$ 的和高度为 $1$ 的一定是一个连通块，因为你考虑一个点周围高度全是 $1$，只有他是 $0$，不如直接把他高度也变成 $1$，这样一定不劣。</p><p>现在题目就被转化的很简单了，现在就等于给每个点求一个高度，使得对于每一条从起点到终点的路径高度变化且只变化一次，也就是我们将所有左右高度不一样的边割掉，起点终点不连通，现在我们就转化成了最小割了，建对偶图直接跑就行了。</p><h3 id="洛谷-P7916-CSP-S-2021-交通规划"><a href="https://www.luogu.com.cn/problem/P7916">洛谷 P7916 [CSP-S 2021] 交通规划</a></h3><p>首先先思考一下 $k=2$ 怎么做，不难发现这个跟上面那个海拔是一毛一样的，就是将白点看成高度为 $0$，黑点看成高度为 $1$。</p><p>考虑怎么推广这个东西，首先有一个很暴力的直接优化，就是直接在原图上跑最小割，拼上上面的 $k=2$，这样就可以得到 $80pts$ 了。</p><p>其实还有一个 $k=3$，这个也挺有用的。（但是部分分没给）</p><p>因为流没有前途，所以还是从对偶图角度考虑。</p><p>不难发现一定有两个颜色相同，并且他俩一定相邻，就比如说下图：</p><p><img src="https://sjzezoj.com/image_hosting/zhhdk2t6gx.png" alt=""></p><p>假设原图是黄框，我们把黑色附加点看成红色点，白色附加点看成蓝色点，现在我们把网格图向外扩充一圈，现在将图标号，最外层的编号是按绿线分割的，编号完也就是下图：（<s>其实上面的文字解释我自己都看不懂</s>）</p><p><img src="https://sjzezoj.com/image_hosting/vyqnvawpkz.png" alt=""></p><p>考虑怎么将红蓝点断开，不难发现就是让 $1,2$ 成为对偶图源汇点。</p><p>同理，如果有很多红点很多蓝点，但是所有红点都相邻，也可以让”左边和红点相邻，右边和蓝点相邻“的面作为源点，让“左边和蓝点相邻，右边和红点相邻“（这里的左右都是按照射线编号顺序编号的左右，例如上图中的 $2$ 为到达面，这个不是肉眼看的左右）的面作为汇点直接跑最短路。</p><p>正解：</p><p>现在你什么性质都没有了😔，但是不难从上面的得出，我要是相同颜色的点相邻是没有任何用的（同 $k=3$，所以下面不考虑这种情况），我们定义”左边和红点相邻，右边和蓝点相邻“的面为出发面，”左边和蓝点相邻，右边和红点相邻“的面为到达面，首先这两种面的数量肯定一样，考虑我们给他们配对，还是按题目中给的射线编号顺序方法给所有出发面到达面重标号，假设我们将编号为 $l$ 的面和编号为 $r$ 的面匹配（这里要求两个面不是同一种面），不妨假设 $l$ 为出发面，我们直接跑从 $l$ 到 $r$ 的最短路，然后把所有最短路上的边割掉，发现这个操作使得 $l,r$ 内所有的蓝点都到达不了这个 $l$ 左边相邻的红点了，就比如下图：</p><p><img src="https://sjzezoj.com/image_hosting/r600vulri0.png" alt=""></p><p>你的 $l$ 是右上角的红点到右上角的蓝点，$r$ 是左下角的蓝点到右边的另一个红点，你这样建图不会像橙边这样割，因为上面那个蓝点还是能到达右上角的红点，但是可以像粉边这样割，然后你发现你这样分出来的一定是正确的，因为你考虑一个 $1,4$，$2,3$ 的配对方法（下图），你在中间留的是一样颜色的点，割出去的是颜色一样的点，归纳一下就行了。</p><p><img src="https://sjzezoj.com/image_hosting/o1ulrgjo1u.png" alt=""></p><p>那么为什么这样配对找到的最小值一定是答案呢？</p><p>额，你发现这玩意好像就是和答案一一对应的。（最终答案中肯定没有卐的形状，怎么着都能断一些边）</p><p>然后发现你的配对方案和括号序列很像，不会相交（即出现 $1,3$ 配对，$2,4$ 配对这种情况），因为如果这样的话你 $1,3$ 的最短路一定和 $2,4$ 的最短路相交，相交是不优的，不如改成 $1,2$ 配对，$3,4$ 配对。</p><p>把这个段环成链，随便 $dp$ 一下就好了。</p><p>设 $f_{l,r}$ 表示将 $[l,r]$ 匹配好的最小代价，转移有：</p><p>$f_{l,r}=\min{f_{l+1,r-1}+dis_{l,r},\min\limits_{k=l}^{r}{f_{l,k}+f_{k+1,r}}}$，其中 $dis_{l,r}$ 为上面所说的让 $l,r$ 匹配，两点间的最短路。</p><p>参考链接：<a href="https://www.cnblogs.com/lfri/p/9939463.html">平面图的基本概念及性质 - Rogn - 博客园</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>对偶图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知道几百年前写的计数 dp 博客</title>
    <link href="/2023/08/15/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%87%A0%E7%99%BE%E5%B9%B4%E5%89%8D%E5%86%99%E7%9A%84%E8%AE%A1%E6%95%B0%20dp%20%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/08/15/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%87%A0%E7%99%BE%E5%B9%B4%E5%89%8D%E5%86%99%E7%9A%84%E8%AE%A1%E6%95%B0%20dp%20%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>计数是真的菜/kk，特地总结了一下这几天做的计数 $dp$.</p><h1><a href="https://www.luogu.com.cn/problem/CF1606E">CF1606E</a></h1><p>设 $f_{i, j}$ 表示当场上还有 $i$ 个英雄，血量最大值为 $j$ 且最后无人存活的方案数。</p><p>当再进行一轮所有英雄都要寄时：</p><p>$f_{i, j} = j ^ i - (j - 1) ^ i$</p><p>$j ^ i$ 为所有血量的选择方案， $(j - 1) ^ i$ 为没有人血量 $j$ 的选择方案，即不合法方案。</p><p>当在进行一轮后还有英雄存活时：</p><p>枚举一个 $k$ 表示在进行一轮后剩余存活人数</p><p>$f_{i, j} = f_{k, j - i + 1} \times C ^ {i - k}_{i} \times (i - 1) ^ {i - k}$</p><p>时间复杂度 $O(n ^ 2 x log_2{n})$</p><p>$code  : $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">507</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br>LL f[N][N];<br>LL c[N][N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br><span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + c[i - <span class="hljs-number">1</span>][j]) % P;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> LL <span class="hljs-title">Qmi</span><span class="hljs-params">(LL a, LL b)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>, x = a;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * x % P;<br>        x = x * x % P;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br><span class="hljs-built_in">Init</span>();<br><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>&#123;<br><span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= j)<br>&#123;<br>f[i][j] = (<span class="hljs-built_in">Qmi</span>(j, i) - <span class="hljs-built_in">Qmi</span>(j - <span class="hljs-number">1</span>, i) + P) % P;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= i; k ++ )<br>f[i][j] = (f[i][j] + f[k][j - i + <span class="hljs-number">1</span>] * <span class="hljs-built_in">Qmi</span>(i - <span class="hljs-number">1</span>, i - k) % P * c[i][k] % P) % P;<br>&#125;<br><br>LL res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>        res = (res + f[n][i]) % P;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.luogu.com.cn/problem/P3914">P3914 染色计数</a></h1><p>样例好水，附一组</p><p>$input : $</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>$output : $</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">16<br></code></pre></td></tr></table></figure><p>很简单的一道计数题/jy</p><p>设 $f_{u, x}$ 表示当前染色染到了 $u$ 节点，当前节点是颜色编号为 $x$ 时的方案数。</p><p>转移显然 ： $f_{u, x} = \prod\limits_{son}\sum\limits_{y = 1} ^ {m , y != x} f_{son, y}$</p><p>但是这样做时间复杂度时 $O(n ^ 3)$ 的。/kk</p><p>观察转移方程，发现可以通过预处理总和来将 $\sum$ 那一层优化掉</p><p>$code : $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5007</span>, M = N * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>h[i] = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Dp</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>&#123;<br><span class="hljs-type">int</span> v = e[i];<br><span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">Dp</span>(v, u);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= m; x ++ )<br>f[u][x] = (LL)(f[u][x] * (LL)(sum[v] - f[v][x] + P) % P) % P;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x &lt;= m; x ++ )<br>sum[u] = (sum[u] + f[u][x]) % P;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= x; j ++ )<br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;y);<br>f[i][y] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">Init</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )<br>&#123;<br><span class="hljs-type">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br><span class="hljs-built_in">Add</span>(u, v), <span class="hljs-built_in">Add</span>(v, u);<br>&#125;<br><br><span class="hljs-built_in">Dp</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>LL res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>res = (res + f[<span class="hljs-number">1</span>][i]) % P;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1><a href="https://www.luogu.com.cn/problem/P6870">P6870 【COCI2019-2020#5】 Zapina</a></h1><p>题不难，就是我是sb</p><p>设 $f_{i, j}$ 表示考虑到第 $i$ 个人， 前 $j$ 道题且有一个人开心的方案数。</p><p>让第 $i$ 个人开心：</p><p>$f_{i, j} = C_{j} ^ {i} \times$</p><p>不让第 $i$ 个人开心：</p><p>代码有点阴间，就不放了/hanx</p><h1><a href="https://www.luogu.com.cn/problem/CF367E">CF367E</a></h1><h1><a href="https://www.luogu.com.cn/problem/CF1051D">CF1051D</a></h1><h1><a href="https://www.luogu.com.cn/problem/CF425E">CF425E</a></h1><p><strong>注意是集合</strong>， 和 <a href="https://www.luogu.com.cn/user/392727">zzq</a> 大佬讨论了好半天 <s>我是sb</s>。</p><p>设 $f_{i, j}$ 表示当右端点都小于等于 $i$ ，$f(S) = j$ 时的方案数</p><p>考虑怎么扩展 $j$</p><p>枚举上一个线段的右端点 $k$, 可得转移方程</p><p>$f_{i, j} = f_{k, j - 1} \times (2 ^ {i - k} - 1) \times $</p><p>写个屁，我不写了c</p><h1><a href="https://www.luogu.com.cn/problem/CF1515E">CF1515E</a></h1><h1><a href="https://www.luogu.com.cn/problem/CF559C">CF559C</a></h1><h1><a href="https://sjzezoj.com/problem/1474">S2OJ 排列题</a></h1><h1><a href="https://sjzezoj.com/problem/879">小 Y 的背包计数问题</a></h1><h1><a href="https://www.luogu.com.cn/problem/P5664">P5664 [CSP-S2019] Emiya 家今天的饭</a></h1><p>寄，太难了/kk</p><p>发现前两个条件很好处理，但是第三个不会/kk</p><p>然后<s>看了题解</s>发现如果最多只会有一列不合法，考虑计算不合法状态然后容斥，容斥后就可以单独考虑每一行了。</p><p>设 $f_{i, j, k}$ 表示考虑到第 $i$ 行，一共选了 $j$ 道菜，枚举的当前列有 $k$ 道菜的方案数。</p><p>这样做时间复杂度是 $O(n ^ 3m)$ 的，可以获得 $84pts$ 的好成绩！</p><p>考虑优化，发现我们最后的答案要统计的是 $k &gt; \lfloor \frac{j}{2} \rfloor$ 的 $dp$ 结果，我们只关心 $k$ 与 $j$ 的关系，这样就可以压掉一位。</p><p>至于怎么压，我们把上面的式子变一下形变为 $2k + n - j &gt; n$</p><p>其中 $n - j$ 就是我们没有选的行数</p><p>那么就有了一种神奇的定义状态方法</p><p>我们设不选一行的权值为 $1$, 选当前列的权值为 $2$。 （这里的权值是我自己定义的，权值是根据上面式子的常数设的）</p><p>设 $f_{j, k}$ 表示考虑到第 $j$ 行， 权值为 $k$ 的方案数。</p><p>枚举一列 $i$ 可得转移方程</p><p>$f_{j, k} = (f_{j, k} + f_{j - 1, k} \times (cnt_j - a_{j, i})) \mod P$ 选了一个其他列</p><p>$f_{j, k} = (f_{j, k} + f_{j - 1, k - 2} \times a_{j, i}) \mod P$ 选了当前列</p><p>$f_{j, k} = (f_{j, k} + f_{j - 1, k - 1}) \mod P$ 没有选</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">107</span>, M = <span class="hljs-number">2007</span>;<br><span class="hljs-type">int</span> a[N][M];<br>LL cnt[N];<br><span class="hljs-type">int</span> n, m;<br>LL f[N][N * <span class="hljs-number">2</span>];<br>LL res = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n * <span class="hljs-number">2</span>; j ++ )<br>f[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>cnt[i] = (cnt[i] + a[i][j]) % P;<br>&#125;<br>res = res * (cnt[i] + <span class="hljs-number">1</span>) % P;<br>&#125;<br>res -- ;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>&#123;<br><span class="hljs-built_in">Init</span>();<br><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= j * <span class="hljs-number">2</span>; k ++ ) <br>&#123;<br>f[j][k] = (f[j][k] + f[j - <span class="hljs-number">1</span>][k] * (cnt[j] - a[j][i])) % P;<br><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>) f[j][k] = (f[j][k] + f[j - <span class="hljs-number">1</span>][k - <span class="hljs-number">2</span>] * a[j][i]) % P;<br><span class="hljs-keyword">if</span> (k) f[j][k] = (f[j][k] + f[j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>]) % P;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i ++ )<br>res = ((res - f[n][i]) % P + P) % P;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>woc之前写的题都好 naive 呀/kk</p><h1><a href="https://atcoder.jp/contests/arc059/tasks/arc059_d">ARC059F</a></h1><p>状态很显然，设 $f_{i,j}$ 表示用了 $i$ 次操作，现在串里面有 $j$ 个数字<br>发现删掉的数字可以是 $0$ 或 $1$,但是最后和串匹配上的必须一样，所以让 $\times 2$ 的贡献在删去时考虑<br>注意没有数也可以退格</p><p>$code$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">namespace</span> IO&#123;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rd</span><span class="hljs-params">(T &amp;x)</span></span>&#123;<br>x=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> f=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> c=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) f|=c==<span class="hljs-string">&#x27;-&#x27;</span>,c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(<span class="hljs-string">&#x27;0&#x27;</span>&lt;=c&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=x*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>),c=<span class="hljs-built_in">getchar</span>();<br>x=f?-x:x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> ...Args&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rd</span><span class="hljs-params">(T &amp;x,Args &amp;...args)</span></span>&#123;<span class="hljs-built_in">rd</span>(x),<span class="hljs-built_in">rd</span>(args...);&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">wt</span><span class="hljs-params">(<span class="hljs-type">char</span> c,T x)</span></span>&#123;<br><span class="hljs-type">int</span> stk[<span class="hljs-number">114</span>],top=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) x=-x,<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">do</span> stk[++top]=x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>; <span class="hljs-keyword">while</span>(x);<br><span class="hljs-keyword">while</span>(top) <span class="hljs-built_in">putchar</span>(stk[top--]+<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-built_in">putchar</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> ...Args&gt; <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">wt</span><span class="hljs-params">(<span class="hljs-type">char</span> c,T &amp;x,Args &amp;...args)</span></span>&#123;<span class="hljs-built_in">wt</span>(c,x),<span class="hljs-built_in">wt</span>(c,args...);&#125;<br>&#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> IO;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5007</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">char</span> s[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ONLINE_JUDGE</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">rd</span>(n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>),m=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++) f[i][j]=(f[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">max</span>(j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>)]+<span class="hljs-number">2ll</span>*f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>])%P;<br>&#125;<br><span class="hljs-built_in">wt</span>(<span class="hljs-string">&#x27;\n&#x27;</span>,f[n][m]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计数 dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>傻逼三角函数学习笔记</title>
    <link href="/2023/08/15/%E5%82%BB%E9%80%BC%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/15/%E5%82%BB%E9%80%BC%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3t913768.png" alt=""></p><p>除了上面这张图都是贺的<a href="https://space.bilibili.com/14229967">一数</a>的</p><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%BC%A6%E5%87%BD%E6%95%B0">正弦</a>：$\sin$ ，<a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%BC%A6">余弦</a>：$\cos$ ，<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%87%E5%87%BD%E6%95%B0">正切</a>：$\tan$ ，<a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%88%87">余切</a>：$\cot$ ，<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%89%B2">正割</a>：$\sec$ ，<a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%89%B2">余割</a>：$\csc$</p><p>任意角三角函数：在平面直角坐标系上画一个单位圆，角 $\alpha$ 作为角度，边按照三角函数规则比起来就是任意角三角函数，与圆相连的是斜边，对边就是对边，临边就是临边</p><p><img src="https://sjzezoj.com/image_hosting/qbwjzlyh5l.png" alt=""></p><h3 id="同角三角函数的基本关系">同角三角函数的基本关系</h3><p><img src="https://sjzezoj.com/image_hosting/d1v1hk342m.png" alt=""></p><p>首先有 $x^2+y^2=1$</p><ol><li>$\cos^2\alpha+\sin^2\alpha=1$</li><li>$\tan \alpha=\frac{\sin \alpha}{\cos \alpha}$ 注意 $\cos \alpha$ 不能等于 $0$ ，即 $\alpha\not=\frac{\pi}{2}+k\pi,k\in \mathbb{Z}$</li></ol><h3 id="诱导公式">诱导公式</h3><p>这里只用证明第一象限是正确的就可以推广到所有象限了</p><p>$y=\sin \alpha$ 是奇函数</p><p>$y=\cos \alpha$ 是偶函数</p><p>$y=\tan \alpha$ 是奇函数</p><p>画个单位圆就出来了</p><p>$\sin(\frac{\pi}{2}-\alpha)=\cos\alpha$ 这两个角互余</p><p>$\cos(\frac{\pi}{2}-\alpha)=\sin\alpha$ 同理</p><p>$\tan(\frac{\pi}{2}-\alpha)=\cot\alpha$ 定义</p><p>$\sin(\pi-\alpha)=\sin\alpha$</p><p>$\cos(\pi-\alpha)=-\cos(\alpha)$</p><p>$\tan(\pi-\alpha)=-\tan(\alpha)$</p><p><strong>奇变偶不变，符号看象限</strong></p><p>$\sin(\alpha+k\frac{\pi}{2}),\sin(\alpha+k\frac{\pi}{2})$</p><p>当 $k$ 为奇数的时候 $\sin(\cos)$ 变为 $\cos(\sin)$</p><p>将 $k \bmod 4$ 后看<strong>原来</strong>三角函数正负值</p><p>$\sin(\alpha-\frac{3}{2}\pi)=\sin(\alpha+(-3)\frac{\pi}{2})=\cos\alpha$</p><p>$\cos(\frac{7}{2}\pi-\alpha)=cos(\alpha-\frac{3}{2}\pi)=-\sin\alpha$ 第一部转化是因为是偶函数</p><h3 id="三角恒等变换">三角恒等变换</h3><h4 id="三角函数和与差公式">三角函数和与差公式</h4><p>研究多个角之间的关系</p><p>$\sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta$</p><p>$\sin(\alpha+\beta)=\sin\alpha\cos\beta-\cos\alpha\sin\beta$</p><p>$\cos(\alpha+\beta)=\cos\alpha\cos\beta-\sin\alpha\sin\beta$</p><p>$\cos(\alpha-\beta)=\cos\alpha\cos\beta+\sin\alpha\sin\beta$</p><p>$\tan(\alpha+\beta)=\frac{\tan\alpha+\tan\beta}{1-\tan\alpha\tan\beta}$</p><p>$\tan(\alpha+\beta)=\frac{\tan\alpha-\tan\beta}{1+\tan\alpha\tan\beta}$</p><p>后面柿子的符号可以通过角的大小变化来记</p><h4 id="辅助角公式">辅助角公式</h4><p>$\sin\alpha+\cos\alpha=\sqrt2(\sin\alpha\frac{1}{\sqrt2}+\cos\alpha\frac{1}{\sqrt2})$</p><p>因为 $\sin45^\circ=\cos45^\circ=\frac{1}{\sqrt2}$</p><p>所以原式等于 $\sqrt2(\sin\alpha\cos45^\circ+\cos\alpha\sin45^\circ)=\sqrt2\sin(\alpha+45^\circ)$</p><p>推广：</p><p>$A\sin\alpha+B\cos\alpha=\sqrt{A^2+B^2}(\sin\alpha\frac{A}{\sqrt{A^2+B^2}}+\cos\alpha\frac{B}{\sqrt{A^2+B^2}})$</p><p>发现一定可以找到一个角 $\beta$ 使得 $\cos\beta=\frac{A}{\sqrt{A^2+B^2}},\sin\beta=\frac{B}{\sqrt{A^2+B^2}}$</p><p>所以原始等于 $\sqrt{A^2+B^2}\sin(\alpha+\beta)$</p><h4 id="二倍角公式">二倍角公式</h4><p>我们知道 $\sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta$ ，所以当 $\alpha=\beta$ 时 $\sin2\alpha=2\sin\alpha\cos\alpha$</p><p>同理 $\cos2\alpha=\cos^2\alpha-\sin^2\alpha$</p><p>因为 $\sin^2\alpha+\cos^2\alpha=1$ ，所以 $\cos2\alpha=2\cos^2\alpha-1$ ，同理，也有 $\cos2\alpha=1-2\sin^2\alpha$ ，这玩意是可以降次的</p><p>$\tan2\alpha=\frac{2\tan\alpha}{1-\tan^2\alpha}$</p><h3 id="解三角形">解三角形</h3><h4 id="正弦定理">正弦定理</h4><p><img src="https://sjzezoj.com/image_hosting/7j7n4w05ct.png" alt=""></p><p>$\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}=2R,R$ 是外接圆半径</p><p>证明：作垂线就行了，$2R$ 就做一个这个就好了<img src="https://sjzezoj.com/image_hosting/a95z4s1okb.png" alt=""></p><h4 id="余弦定理">余弦定理</h4><p>$c^2=a^2+b^2-2ab\cos C$</p><p>推论：$\cos C=\frac{a^2+b^2-c^2}{2ab}$</p><p>证明：设向量 $AB$ 为 $\vec{c}$ ，向量 $CB$ 为 $\vec{a}$ 向量 $CA$ 为 $\vec{b}$</p><p>有 $\vec{c}=\vec{a}-\vec{b}$</p><p>$\vec{c}^2=(\vec{a}+\vec{b})^2$</p><p>$c^2=\vec{a}^2+\vec{b}^2+2\vec{a}\vec{b}$</p><p>$c^2=a^2+b^2+2ab\cos C$</p>]]></content>
    
    
    
    <tags>
      
      <tag>文化课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLAST.tv Paris Major 2023 观后感</title>
    <link href="/2023/08/15/BLAST.tv%20Paris%20Major%202023%20%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <url>/2023/08/15/BLAST.tv%20Paris%20Major%202023%20%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="摩尔投票">摩尔投票</h2><p>方法：</p><p>大概操作就是记录一个 $major,cnt$ ，顺序遍历数组 $a$，假设遍历到了第 $i$ 个，当 $cnt=0$ 时让 $major=a_i$ ， 当 $cnt$ 不为 $0$ 时，如果 $a_i=major$ 让 $cnt$ 加 $1$ ，否则减 $1$</p><p>这样做的时间复杂度是 $O(n)$ 的，空间复杂度是 $O(1)$ 的。</p><p>注意这个是有绝对众数的时候才是对的。</p><p>拓展：</p><p>现在你要求出现次数超过 $\frac{n}{k}$ 的，显然数的个数是小于 $k$ 的，不然 $n$ 个肯定不够</p><p>其实做法和上面差不多，现在要开两个数组 $major_i,cnt_i$</p><p>操作：</p><p>首先如果 $x$ 本身是候选者的话，则对其出现次数加一</p><p>如果不是的话，如果有 $cnt=0$ 的位置那么就让 $x$ 成为候选者，出现次数变为 $1$，否则让所有候选者出现次数减 $1$</p><p>注意这个不一定所有都是对的，但是正确的答案一定包括</p><p>这个万一就感觉有点抽象了，所以还是证明一下吧</p><p>考虑反证法，假设 $x$ 出现了 $y&gt;\frac{n}{k}$ 次，但是他不在答案里面</p><ol><li>他就没有进入过 $major$ 数组：那么他肯定让所有候选者减去了 $y$ 次，但是由 $y&gt;\frac{n}{k}$ 知 $y\times k &gt; n$ 不符合题意</li><li>他进入过然后被干掉了：同理，他被干掉了说明肯定所有候选者都减去了 $y$ 次，同上，还是寄</li></ol><p>那么摩尔投票有什么用呢？</p><h3 id="摩尔投票具有结合律，可以用-ds-乱搞">摩尔投票具有结合律，可以用 $ds$ 乱搞</h3><p>这玩意就和线性基很像，就直接把一个插进另一个就行了</p><h4 id="CF643G-Choosing-Ads"><a href="https://www.luogu.com.cn/problem/CF643G">CF643G Choosing Ads</a></h4><p>就是板子</p><p><a href="https://codeforces.com/contest/643/submission/205378557">code</a></p><h3 id="更加神奇的东西">更加神奇的东西</h3><p><s>其实感觉和摩尔投票没啥关系了</s></p><p>假设我现在猜一手区间众数为 $x$ ，现在就可以把等于 $x$ 的设为 $1$ ，否则设为 $-1$ ，这样 $\text{chk}$ 一个区间是否众数是 $x$ 就可以 $O(1)$ 了</p><p>因为是绝对众数，所以我枚举一遍我猜的众数就可以求出所有区间的众数了，<s>但是这是 $O(n^2)$ 的</s></p><p>但是还有性质 😍😍😍</p><ol><li>当区间 $[l,r]$ 有绝对众数 $x$ 时，区间 $[l,k],[k+1,r],k\in[l,r)$ 肯定有一个的有绝对众数并且他是 $x$ <s>废话</s></li><li>区间 $[l,l],[l,l+1],[l,l+2],…,[l,r]$ 的本质不同绝对众数个数只有 $log_2$ 个，原因是我要是想成为绝对众数要大于区间一半，就比如假设现在序列长度为 $n$ ，你至少要加 $n+1$ 个数才能成为新的绝对众数</li></ol><p>将上面两个结合起来后，就有了一个非常 😎 的结论，就是跨过区间 $[l,r]$ 中点 $mid$ 的所有区间的绝对众数个数是 $\log$ 级别的，具体来说，根据性质 $1$，就是区间 $[l,l],[l,l+1],…,[l,mid]$ 和 $[mid,mid],[mid,mid+1],…,[mid,r]$ 的绝对众数集合一定是包含所有上述区间的绝对众数的，又根据性质 $2$ ，可以知道只有 $\log$ 个</p><h4 id="ARC159F-Good-Division"><a href="https://www.luogu.com.cn/problem/AT_arc159_f">ARC159F Good Division</a></h4><p>题意：定义可以每次删去一对相邻不同的数把序列删空，求将数组 $A$ 划分成若干个合法的子串的方案数</p><p>首先转化一下题意，一个序列是好的当且仅当他没有绝对众数，这个显然是正确的，因为题目里面给的操作就是一个摩尔投票的过程。</p><p>然后我们就有 $O(n^2)$ 的做法了，🐍 $f_i$ 表示前 $i$ 个数的方案数，转移就枚举最后一个序列长度就行了，好棒！但是过不了😔</p><p>考虑利用上面那个东西优化，搞一个类似 $cdq$ 优化 $dp$ 的东西</p><p>假设现在求的区间是 $[l,r]$ ，先递归 $[l,mid]$ 算出左边的值，考虑左边对右边的贡献，根据上面性质，跨过中点的区间只有 $\log$ 个众数，发现一个区间只有一个绝对众数，所以可以先让所有 $[mid+1,r]$ 的 $f$ 加上 $[l,mid]$ 的 $f$， 然后直接枚举众数减去不合法的，精细实现一下应该可以做到 $O(n\log^2 n)$</p><p><a href="https://atcoder.jp/contests/arc159/submissions/41301372">code</a> (上面<s>肯定 🤡</s> 可能讲的不是很清楚)</p><p>但是我还想讲一个好玩的东西，虽然好像跟摩尔投票无关，但是跟上面的那个玩意有关，有了这个就很好做到 $O(n\log^2n)$ 了</p><blockquote><p>给定长度为 $n$ 一个 $0,1$ 序列 $A$，求 $1$ 个数比 $0$ 个数多的区间个数 $n \le 反正单 \log 过不去$</p></blockquote><p>首先这个用 $bit$ 很容易做到 $O(n\log n)$ ，但是还不够优秀 😅</p><p>首先肯定的转化是把 $0$ 改为 $-1$ ，做一个前缀和，现在就是要对于每个 $i$ 求 $sum_i &gt;sum_{j-1}$ 的 $j$ 的个数了</p><p>现在有一个很 🤩 的做法，我们把 $1,-1$ 看为折线</p><p>比如 $101001$ 这个就长成这样</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rn4z9c7r.png" alt=""></p><p>发现每次只会移动一位，也就是说我每移动一次就只有一个纵坐标加入或减去</p><p>算了上面的你一定没有听懂 🧐</p><p>其实就是你对 $[-n,n]$ 的每个位置开一个桶，统计 $[1,i]$ 有几个 $sum_i$ 是当前纵坐标，然后你再记一个 $pre$ 表示坐标有多少 $j$ 满足 $j&lt;i,sum_j&lt;sum_i$，走上来就把桶贡献加进 $pre$，走下去就把桶从 $pre$ 中删掉</p><p>应用：</p><h4 id="Coming（coming）"><a href="http://c.gdfzoj.com/contest/15/problem/531">Coming（coming）</a></h4><p><s>这是 [生成函数] 的题看不了</s></p><p><s>题意也不能说</s></p><p>算了谁能看谁看吧</p><p><a href="https://www.cnblogs.com/lnyx/p/17391286.html">题解</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>摩尔投票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC G Ex 简要题解</title>
    <link href="/2023/08/15/ABC%20G%20Ex%20%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/15/ABC%20G%20Ex%20%E7%AE%80%E8%A6%81%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="ABC212G-Power-Pair"><a href="https://www.luogu.com.cn/problem/AT_abc212_g">ABC212G Power Pair</a></h3><p>推柿子题</p><p>$\sum\limits_{x}^{P-1}\sum\limits_{y}^{P-1} \exists n \in \mathbb{N}\ x^n \equiv y(\bmod P)$</p><p>$1+\sum\limits_{x=1}^{P-1}\sum\limits_{y=1}^{P-1} \exists n \in \mathbb{N}\ x^n \equiv y(\bmod P)$</p><p>考虑模 $P$ 意义下的原根 $g$ ,有 $x=g^a,y=g^b$</p><p>$1+\sum\limits_{x=1}^{P-1}\sum\limits_{y=1}^{P-1} g^{an} \equiv g^{b} (\bmod P)$</p><p>$1+\sum\limits_{x=1}^{P-1}\sum\limits_{y=1}^{P-1} an \equiv b (\bmod P-1)$</p><p>这个可以看成一个长度为 $P-1​$ 的环，我每次在上面走 $a​$ 步，求 $b​$ 的数量，这个是 $\frac{P-1}{\gcd(a,P-1)}​$ 个。</p><p>$1+\sum\limits_{a=1}^{P-1}\frac{P-1}{\gcd(a,P-1)}​$</p><p>$1+\sum\limits_{d|(P-1)} \frac{P-1}{d}\sum\limits_{a=1}^{P-1}[\gcd(a,P-1)=d]$</p><p>$1+\sum\limits_{d|(P-1)} \frac{P-1}{d}\varphi(\frac{P-1}{d})$</p><p>现在就可以求了</p><p>$1e12​$ 以内的约数数最多的数有 $6720​$ 个约数，跑不满</p><p><a href="https://atcoder.jp/contests/abc212/submissions/40783284">code</a></p><h3 id="ABC212H-Nim-Counting"><a href="https://www.luogu.com.cn/problem/AT_abc212_h">ABC212H Nim Counting</a></h3><p>可以说只要会 $FWT$ 就可以切</p><p>题意：给定长度为 $K​$ 的数组 $A​$ ，给定 $N​$ ，现在你要选择<strong>有</strong> $[1,N]​$ 堆石子，每一堆石子的数量 $\in A​$ ，现在玩 $nim​$ 游戏，求先手获胜的局面有多少种</p><p>其实就是满足在 $x^a \times x^b=x^{a\ xor \ b}$ 下求 $[x^t]\sum\limits_{i=1}^{n}(f(x))^i$ 其中 $t \in [1,$值域$]$</p><p>因为 $FWT(A+B)=FWT(A)+FWT(B),FWT(A\ xor \ B)=FWT(A) \times FWT(B)​$</p><p>所以可以首先先 $FWT​$，然后对 $FWT​$ 的每一项做 $\sum\limits_{i=1}^{n}{a_x}^i=\frac{ {a_x}^{n+1} - a}{a-1}​$，然后 $IFWT​$</p><p><a href="https://atcoder.jp/contests/abc212/submissions/40785896">code</a></p><h3 id="ABC213G-Connectivity-2"><a href="https://www.luogu.com.cn/problem/AT_abc213_g">ABC213G Connectivity 2</a></h3><p>小清新计数题</p><p>看数据范围考虑状压</p><p>设 $f_S​$ 表示现在与一联通的子图点集是 $S​$ 的方案数，转移发现不好转移，所以正难则反，用总数减去不合法</p><p><a href="https://atcoder.jp/contests/abc213/submissions/40575030">code</a>（这里 $f$ 为了卡常没有点 $1$</p><h3 id="ABC214G-Three-Permutations"><a href="https://www.luogu.com.cn/problem/AT_abc214_g">ABC214G Three Permutations</a></h3><p>个人感觉非常困难</p><p><a href="https://www.cnblogs.com/lnyx/p/17318334.html"><strong>详细写了题解</strong></a></p><h3 id="ABC214H-Collecting"><a href="https://www.luogu.com.cn/problem/AT_abc214_h">ABC214H Collecting</a></h3><p>洛谷题解全是扯淡的</p><p>首先发现可以直接建图流，但是这样时间复杂度是 $O(nmk)​$ 的，$% 114514​$ 过不了，考虑优化</p><p>发现有一个东西是 $Dijsktra​$ 求最小费用流，时间复杂度是 $O(nm+km\log m)​$ 的，时间复杂度瓶颈在一开始要求一遍 $spfa​$ ，考虑怎么建出来图没有负权边，之前的建图要建负权边是因为我要求的是最大费用最大流，发现这玩意就是最小浪费代价最大流，这玩意要怎么弄呢，首先缩点成为一个 $dag​$ ，按 $dag​$ 层数标号，我要是从一个编号为 $i​$ 的点到一个编号为 $j​$ 点的话中间的肯定选不上，要是走到这里就不走了说明后面的全选不了，这样就可以做了</p><p><a href="https://atcoder.jp/contests/abc214/submissions/40922908">code</a></p><h3 id="ABC215G-Colorful-Candies-2"><a href="https://www.luogu.com.cn/problem/AT_abc215_g">ABC215G Colorful Candies 2</a></h3><p>挺傻逼的一道题</p><p>但是我降智没想出来/ng</p><p>退役算了/cf</p><p>假设现在有 $m$ 种颜色，你选 $x$ 个球，那么选颜色 $i$ 的概率就是 $\frac{ {n \choose x} - {n-sum_i \choose x} }{n \choose x}$</p><p>这样就可以 $O(n^2)$ 了</p><p>然后发现本质不同的 $sum_i$ 个数时 $\sqrt n$ 级别的，所以可以 $O(n\sqrt n)$ 做了</p><h3 id="ABC215H-Cabbage-Master"><a href="https://www.luogu.com.cn/problem/AT_abc215_h">ABC215H Cabbage Master</a></h3><p>学习到的很多</p><p>很容易联想到二分图，每一个球是左部点，每一个盒子是右部点（当然做的时候不用建出来，不然就寄了，所以下面说的左部点都是对于颜色，右部点都是对于盒子），求完美匹配</p><p>考虑霍尔定理</p><p>$n&lt;=20$ 可以直接枚举，但是发现右部点的权值不好算，所以可以改一下枚举的定义，即我选了一些右部点，他们所有可达的左部点集合为 $S$ ，这样就可以 $FWT$ 算右部点权值了</p><p>假设现在我选的左部点权值是 $x​$ ，右部点权值是 $y​$ ,第一问答案就是 $cnt=min\left{y-x+1\right}​$</p><p>将不用删点特判掉之后考虑求方案数</p><p>当一个左部点集合 $S$ 删去 $cnt$ 个点时没有完美匹配当且仅当 $\exists \ T \  S \in T$ 且 $T$ 的 $y-x+1=cnt$ ，为了不算重，我们钦定 $S$ 里面包含的颜色都至少被删去一个球。</p><p>至于怎么求，考虑容斥</p><p>先提前算出不钦定的值，然后外层枚举现在处理到第几个颜色，内层枚举集合 $S$ 现在等于时颜色编号小于 $S$ 的都已经钦定选了，然后你减去把现在枚举的颜色去掉的 $dp$ 值，仔细想想发现很正确</p><p><a href="https://atcoder.jp/contests/abc215/submissions/40792589">code</a></p><h3 id="ABC219H-Candles"><a href="https://www.luogu.com.cn/problem/AT_abc219_h">ABC219H Candles</a></h3><p>可能？是套路题</p><p>但是我不会/ng</p><p>因为我不能记时间，所以可以考虑费用提前计算</p><p>首先先思考假如蜡烛可以燃烧到负数，发现这就是 <a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯</a> ，但是现在不能燃烧到负数，也就是 $\max(0,a_i)$ ，于是就有一个思路就是在第 $i$ 根蜡烛的时候把 $a_i$ 和 $0$ 都转移一遍，因为是取 $\max$ ，所以最后答案是正确的</p><p>现在我不知道有多少蜡烛是没到就会燃尽，所以我区间 $dp​$ 多记一维表示当前区间外有 $i​$ 根蜡烛未燃尽，这样就可以实现上述转移了</p><p>设 $f_{l,r,i,0/1}$ 表示在区间 $[l,r]$ ，区间外有 $i$ 根蜡烛在燃烧，现在在 左/右 端点时的燃烧掉的最小值</p><p>$f_{l,r+1,i,0}=\min\left{f_{l,r,i,0/1}+i \times dist+a_{r+1},f_{l,r,i+1,0/1}+i \times dist\right}​$  其他转移同理</p><p>$\min​$ 中前面的就是 $r+1​$ 的熄灭了，后面的时没熄灭的</p><p><a href="https://atcoder.jp/contests/abc219/submissions/40618822">code</a></p><h3 id="ABC230G-GCD-Permutation"><a href="https://www.luogu.com.cn/problem/AT_abc230_g">ABC230G GCD Permutation</a></h3><p>糗大了，做法是个傻逼玩意</p><p>直接推柿子。</p><p>题目要求：<br>$$<br>\sum_{i=1}^{n}\sum_{j=i}^{n}[\gcd(i,j)\neq1][\gcd(P_i,P_j)\neq1]<br>$$<br>有 $\gcd$ ，考虑莫比乌斯反演，发现莫比乌斯反演好像只能做 $\gcd(i,j)=1$ ，所以先推一下 $\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n}[\gcd(i,j)=1][\gcd(P_i,P_j)=1]$ <s>其实是我一开始看错题了</s>。</p><p>首先将 $[\gcd(i,j)=1]$ 莫比乌斯反演一下：<br>$$<br>\begin{eqnarray}<br>&amp;\sum_{i=1}^{n}&amp;\sum_{j=i}^{n}[\gcd(i,j)=1][\gcd(P_i,P_j)=1] \<br>=&amp;\sum_{d=1}^{n}&amp;\mu(d)\sum_{d\mid i}^{n}\sum_{d\mid j}^{n}[\gcd(P_i,P_j)=1][i \le j] \<br>\end{eqnarray}<br>$$<br>然后将 $[\gcd(P_i,P_j)=1]$ 反演一下：<br>$$<br>\begin{eqnarray}<br>&amp;\sum_{d=1}^{n}&amp;\mu(d)\sum_{k=1}^{n}\mu(k)\sum_{d\mid i,k\mid P_i}^{n}\sum_{d\mid j,k \mid P_j}^{n}[i \le j] \<br>=&amp;\sum_{d=1}^{n}&amp;\mu(d)\sum_{k=1}^{n}\mu(k)\ \frac{sum(d,k) (sum(d,k)+1)}{2} \<br>\end{eqnarray}<br>$$<br>其中 $sum(d,k)$ 表示 $d \mid i,k \mid P_i$ 的 $i$ 的个数。</p><p>不难发现对于每一个数 $i$ 最多只会对 $sum$ 数组贡献 $\log^2$ 次，因为约数个数是 $\log$ 级别的，所以时间复杂度 $O(n\log^2 n)$。</p><p>现在已经会做 $\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n}[\gcd(i,j)=1][\gcd(P_i,P_j)=1]​$ ，考虑怎么转化回题目本身，考虑莫比乌斯反演的本质是依靠 $\sum\limits_{d \mid n}\mu(d)=[n=1]​$ 这个柿子搞的，现在我们要求的是跟这个正好相反的柿子，也就是说只要构造出来一个函数 $\xi(i)​$ 满足 $\sum\limits_{d \mid n}\xi(d)=[n\neq1]​$ 就可以了，这个很好构造，考虑 $\mu​$ 的定义：<br>$$<br>\mu(i) =<br>\begin{cases}<br>1 \quad n = 1 \<br>0 \quad \text{ $i$ 含有质因子平方}\<br>(-1)^k \quad \text{ $k$ 为 $i$ 的质因子个数}<br>\end{cases}<br>$$<br>首先因为 $n=1$ 时要求 $\xi(n)=0$ ，所以：<br>$$<br>\xi(i) =<br>\begin{cases}<br>0 \quad n = 1 \<br>\end{cases}<br>$$<br>然后考虑为什么当 $n\neq1$ 时 $\mu(i)=0$ ，假设 $n$ 有 $k$ 个质因子，根据定义 $\sum\limits_{d\mid n}^{n}\mu(d)=\sum\limits_{i=0}^{k}(-1)^i{k \choose i}$ ，因为有平方因子贡献为 $0$ ，所以直接枚举有几个因子就可以了。</p><p>把平方质因子搞掉这个性质很好，我们可以借鉴过来，也就是我们还是不要平方因子，现在的规则就是：<br>$$<br>\xi(i) =<br>\begin{cases}<br>0 \quad n = 1 \<br>0 \quad \text{ $i$ 含有平方因子}\<br>\end{cases}<br>$$<br>现在就是只要构造出 $f_i$ 满足 $\sum\limits_{i=1}^{k}f_i{k \choose i}=1$ 就可以了，还是借鉴莫比乌斯函数，发现 $\sum\limits_{i=1}^{k}(-1)^k{k \choose i}=-1$ ，所以我们直接取反就好了。</p><p>也就是现在的规则是：<br>$$<br>\xi(i) =<br>\begin{cases}<br>0 \quad n = 1 \<br>0 \quad \text{ $i$ 含有质因子平方}\<br>(-1)^{k-1} \quad \text{ $k$ 为 $i$ 的质因子个数}<br>\end{cases}<br>$$<br>现在我们已经构造出 $\xi$ 了，只要将上面推出来的柿子中的 $\mu$ 换成 $\xi$ 就好了。</p><p><a href="https://atcoder.jp/contests/abc230/submissions/42028680">code</a></p><h3 id="ABC298Ex-Sum-of-Min-of-Length"><a href="https://atcoder.jp/contests/abc298/tasks/abc298_h">ABC298Ex - Sum of Min of Length</a></h3><p>挺神秘的一道题</p><p>题意：给你一棵树，多次询问，每次询问给定两个点 $x,y$，求 $\sum\limits_{u=1}^{n} \min(dist(u,x),dist(u,y))$</p><p>如果只有一个点发现非常好求，直接换根 $dp$ 就好了，现在考虑两个点怎么做</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/esbf9qgy.png" alt=""></p><p>首先肯定是要找出 $u$ 到 $v$ 的中点 $mid$ 的</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jgm5x7mw.png" alt=""></p><p>其中以 $mid$ 为子树的点肯定是到 $u$ , 而剩下的节点是到 $v$</p><p>现在把式子列出来：</p><p>设集合 $S$ 包含以 $mid$ 为子树的的节点（黄色方框包含的节点），集合 $T$ 包含剩下的节点（绿色方框包含的节点）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wzsitxdu.png" alt=""></p><p>$ans=\sum\limits_{u \in S} dist(u,x)+\sum\limits_{u \in T} dist(u,y)$</p><p>$ans=\sum\limits_{u=1}^{n} (dist(u,x)+dist(u,y))-(\sum\limits_{u \in S} dist(u,y)+\sum\limits_{u \in T} dist(u,x))$</p><p>$ans=\sum\limits_{u=1}^{n} (dist(u,x)+dist(u,y))-(\sum\limits_{u \in S} dist(u,mid)+\sum\limits_{u \in T} dist(u,mid)+sz_{mid} \times dist(mid,y)+(n-sz_{mid}) \times dist(mid,x))$</p><p>$ans=\sum\limits_{u=1}^{n} (dist(u,x)+dist(u,y)-dist(u,mid))-sz_{mid} \times dist(mid,y)-(n-sz_{mid}) \times dist(mid,x))$</p><p>哈哈，非常神奇的我们就可以做了</p><p>时间复杂度 $O(n\log n)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>ABC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hall 定理</title>
    <link href="/2023/08/15/hall%20%E5%AE%9A%E7%90%86/"/>
    <url>/2023/08/15/hall%20%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.emojiall.com/img/platform/qq/031@2x.gif" alt="031@2x.gif (56×56) (emojiall.com)"><img src="https://www.emojiall.com/img/platform/qq/074@2x.gif" alt="074@2x.gif (56×56) (emojiall.com)"><img src="https://www.emojiall.com/img/platform/qq/027@2x.gif" alt="027@2x.gif (56×56) (emojiall.com)"><img src="https://www.emojiall.com/img/platform/qq/081@2x.gif" alt="081@2x.gif (56×56) (emojiall.com)"></p><h4 id="霍尔定理">霍尔定理</h4><p>假设现在有二分图，其左部点集合为 $S$，右部点集合为 $T$，我们钦定 $|S|\le|T|$，设 $state(S)$ 表示若选出的左部点集合为 $S$，他们连向的右部点的集合为 $state(S)$。霍尔定理就是：若 $\prod\limits_{T \in S} [|T|\le |state(T)|]=1$，则该图有完美匹配，否则没有。</p><p><a href="https://www.zhihu.com/tardis/zm/art/460373184?source_id=1005">证明可以看这里</a> <s>其实这里讲的比我好多了</s></p><p>现在有几个推广</p><ol><li>若二分图的匹配边数量为 $|S|-k$，则 $\prod\limits_{T \in S} [|T|-k\le |state(T)|]=1$，反之同理。<s>证明还是可以看上面的链接</s></li><li>若现在一个左部点 $x$ 可以匹配 $l(x)$ 个右部点，一个右部点 $y$ 可以匹配 $r(y)$ 个右部点，则存在现定义下的完美匹配的充要条件为 $\prod\limits_{T \in S} [\sum\limits_{x\in T} l(x) \le \sum\limits_{y \in state(T)}r(y)]=1$，这个的证明大概就是把一个左部点 $x$ 拆成 $l(x)$ 个左部点，这样就和霍尔定理一样了</li></ol><p>然后是题目：</p><h3 id="Loj-6062-「2017-山东一轮集训-Day2」Pair"><a href="https://loj.ac/p/6062">Loj #6062. 「2017 山东一轮集训 Day2」Pair</a></h3><p>假设我们已经确定了一个左部点集合 $S$，设右部点集合为 $T$，考虑怎么快速 $chk$ 这个集合是否有完美匹配，考虑霍尔定理，直接做显然不现实，分析性质发现：如果霍尔定理枚举到的集合为 $S$，若 $x,y\in S,a_x\le a_y$，则所有 $x$ 与右部点连的边都被 $y$ 与右部点连的边包含了，所以对于一个左部点集合 $S$，向右部点连的边数可以直接算最大值向右部点连的边数，假设我们设 $a_x$ 是集合中最大的元素， $a_x$ 在集合中的排名为 $k$，不难发现 $|S| \le k$，所以现在这个集合有完美匹配的充要条件就是 $\prod\limits_{x\in S}[\sum\limits_{y\in T}[a_x+a_y\ge h]\ge k_x]=1$，其中 $k_x$ 表示元素 $x$ 在集合 $S$ 中的排名，内部的 $\sum$ 可以用 $lower_bound$ 来解决，所以现在 $chk$ 一个集合的复杂度已经被我们缩小到 $O(n\log n)$ 了。</p><p>现在考虑题目让求的怎么做，发现从一个集合移动到下一个集合只是删掉一个元素再加上一个元素，考虑有 $ds$ 维护这个东西，因为我们需要求出排名，所以肯定是需要维护有序序列的，又因为要支持加入删除，这肯定要更改这个数后面的排名，就是一个区间修改，这样我们就排除了堆等一些简单的 $ds$，发现上面说的操作很线段树，考虑维护一颗线段树，对于第 $i$ 个位置维护排序后的第 $i$ 大（不去重），维护这个点现在在不在 $S$ 中，和式子 $\prod\limits_{x\in S}[\sum\limits_{y\in T}[a_x+a_y\ge h]\ge k_x]=1$ 的值，大概操作方法就是删掉位置 $i$ 的数就让 $[i+1,n]$ 的数全部加 $1$（这个加 $1$ 的原因是后面的 $k$ 全部减了 $1$，所以式子的值要加 $1$），加数同理，不难维护。</p><p><a href="https://loj.ac/s/1802866">code</a></p><h3 id="CF1519F-Chests-and-Keys"><a href="https://www.luogu.com.cn/problem/CF1519F">CF1519F Chests and Keys</a></h3><p><s>这数据范围真离谱</s></p><p>建一个类似于费用流的东西，源点向所有宝箱连一条容量为 $a_i$ 的边，每个钥匙向汇点连一条容量为 $b_i$ 的边，将“在第 $i$ 个箱子上上上第 $j$ 个锁“看成让左部点 $i$ 向右部点 $j$ 连一条容量为 $INF$ 的边，费用为 $c_{i,j}$，不难发现一种连边方法合法等于 $\sum\limits_{T\in S}[\sum\limits_{x\in T}a_x\le\sum\limits_{y\in state(T)}sum(T,y)]$，其中 $S$ 为所有宝箱构成的集合，$state$ 和 $sum$ 和上面写的意思一样，发现这玩意就是霍尔定理推广 $2$，所以现在就等于要找到一张花费最小的有完美匹配的图。</p><p>考虑怎么做这个东西，首先无解很好判断，当每个箱子都上上所有🔒时如果还不行就无解。</p><p><s>然后直接搜就做完了</s></p><p>考虑 dp，设 $f_{i,s}$ 我现在考虑到第 $i$ 个宝箱，每个钥匙还剩下流量状态集合为 $s$（五进制数）时的最小花费，转移的时候就暴力枚举我现在这个宝箱和哪些🔑连边，然后在枚举给每个钥匙多少流量，反正就是全部暴力就对了。</p><p>设 $x=\max\limits_{i=1}^{m}(b_i)$时间复杂度大概是 $O(n\cdot m\cdot x^{m+1})$ 的。</p><p><a href="https://codeforces.com/contest/1519/submission/210866153">code</a></p><h3 id="ARC076F-Exhausted"><a href="https://www.luogu.com.cn/problem/AT_arc076_d">[ARC076F] Exhausted?</a></h3><h3 id="ABC215H-Cabbage-Master"><a href="https://www.luogu.com.cn/problem/AT_abc215_h">[ABC215H] Cabbage Master</a></h3><p>我在<a href="https://www.cnblogs.com/lnyx/p/17364605.html">这篇博客</a>里面有这道题的题解</p>]]></content>
    
    
    
    <tags>
      
      <tag>hall 定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3728 The merchant</title>
    <link href="/2023/08/15/POJ%203728%20The%20merchant/"/>
    <url>/2023/08/15/POJ%203728%20The%20merchant/</url>
    
    <content type="html"><![CDATA[<p>题意好像不清楚：</p><blockquote><p>给定一棵 $n$ 个点的树，每个点有点权 $val_i$，现在有 $q$ 个询问，每次询问给出 $u,v$，设 $u$ 到 $v$ 的路径上的点编号为 $a_1,a_2\cdots a_{len}$，求 $\max\limits_{1 \le x &lt; y\le len}{val_{a_y}-val_{a_x}}$。</p></blockquote><p>因为 $x,y$ 有顺序限制，所以不好直接做，最直观的思路应该就是对于每个询问分治，这样我们就把顺序限制干掉了，但是直接分治的复杂度是 $O(qn\log n)$ 的，直接寄。</p><p>然后我就不会做了。<img src="https://www.emojiall.com/img/platform/qq/013@2x.gif" alt="013@2x.gif (56×56) (emojiall.com)"></p><p>发现这个题没有修改，应该是静态的东西，思考一下有什么东西像这个分治结构，<s>看完题解后</s>发现就是倍增，具体来讲就是我们直接维护 $up_{u,j}$ 表示从 $u$ 走到他的 $2^j-1$ 级祖先的答案，$down_{u,j}$ 表示从 $u$ 的 $2^j-1$ 级祖先走到 $u$ 的答案，$f_{u,j}$ 表示 $u$ 的 $2^j$ 级祖先是谁，$mx_{u,j}$ 表示 $u$ 到他的 $2^j-1$ 级祖先中权值最大值，$mn$ 为最小值。</p><p>在计算 $up$ 的时候是类似于 $up_{u,j}=\max({up_{u,j-1},up_{f_{u,j-1},j-1},mx_{f_{u,j-1},j-1}-mn_{u,j-1}})$，这玩意就是类似于分治区间为 $u$ 到 $j$ 级祖先，然后分治成 $u$ 到 $j-1$ 级祖先和 $f_{u,j-1}$ 到 $j-1$ 级祖先两部分，然后最后的就是当前区间跨过分治中点的答案， $down$ 是同理的。</p><p>最后统计答案也是类似与分治的合并，跟上面的一样。</p><p>code:（POJ 只支持 C++98 <img src="https://www.emojiall.com/img/platform/qq/074@2x.gif" alt="074@2x.gif (56×56) (emojiall.com)">）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">7</span>,Log=<span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> val[N];<br><span class="hljs-type">int</span> up[N][Log],down[N][Log],mx[N][Log],mn[N][Log],f[N][Log];<br><span class="hljs-type">int</span> dep[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>dep[u]=dep[fa]+<span class="hljs-number">1</span>;<br>f[u][<span class="hljs-number">0</span>]=fa,mx[u][<span class="hljs-number">0</span>]=mn[u][<span class="hljs-number">0</span>]=val[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;Log;j++)&#123;<br>f[u][j]=f[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>mx[u][j]=<span class="hljs-built_in">max</span>(mx[u][j<span class="hljs-number">-1</span>],mx[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]);<br>mn[u][j]=<span class="hljs-built_in">min</span>(mn[u][j<span class="hljs-number">-1</span>],mn[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]);<br>up[u][j]=<span class="hljs-built_in">max</span>(up[u][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">max</span>(up[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>],mx[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]-mn[u][j<span class="hljs-number">-1</span>]));<br>down[u][j]=<span class="hljs-built_in">max</span>(down[u][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">max</span>(down[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>],mx[u][j<span class="hljs-number">-1</span>]-mn[f[u][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>]));<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-type">int</span> v=g[u][i];<br><span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep[u]&lt;dep[v]) <span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=Log<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(dep[f[u][j]]&gt;=dep[v]) u=f[u][j];<br>&#125;<br><span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> u;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=Log<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(f[u][j]!=f[v][j]) u=f[u][j],v=f[v][j];<br>&#125;<br><span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ONLINE_JUDGE</span><br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> u,v; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>g[u].<span class="hljs-built_in">pb</span>(v),g[v].<span class="hljs-built_in">pb</span>(u);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> q; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> u,v; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,anc=<span class="hljs-built_in">lca</span>(u,v),MX=<span class="hljs-number">0</span>,MN=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=Log<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(dep[f[u][j]]&gt;=dep[anc]) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(up[u][j],mx[u][j]-MN)),MN=<span class="hljs-built_in">min</span>(MN,mn[u][j]),u=f[u][j]; <br>&#125;<br>ans=<span class="hljs-built_in">max</span>(ans,val[anc]-MN),MN=<span class="hljs-built_in">min</span>(MN,val[anc]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=Log<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(dep[f[v][j]]&gt;=dep[anc]) ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(down[v][j],MX-mn[v][j])),MX=<span class="hljs-built_in">max</span>(MX,mx[v][j]),v=f[v][j];<br>&#125;<br>ans=<span class="hljs-built_in">max</span>(ans,MX-val[anc]),MX=<span class="hljs-built_in">max</span>(MX,val[anc]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(ans,MX-MN));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>竞赛图六步走</title>
    <link href="/2023/08/15/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E5%85%AD%E6%AD%A5%E8%B5%B0/"/>
    <url>/2023/08/15/%E7%AB%9E%E8%B5%9B%E5%9B%BE%E5%85%AD%E6%AD%A5%E8%B5%B0/</url>
    
    <content type="html"><![CDATA[<p>本文为二十一世纪二十年代的最新产物，<strong>作者：[数据删除]</strong></p><p>想转载这辈子都不用联系我了</p><p>本文内容可能过于空虚，建议<strong>先扫一遍</strong>，然后再<strong>分成几个部分</strong>每天读一部分，因为这样你才能掌握<strong>本文的精髓</strong></p><p><strong>竞赛图</strong> 是一个很没用的东西，好比数学中的 解 剖 <strong>青 蛙</strong> 。它也是信奥学习中的不用学习的点，因此把它学好<strong>啥用没有</strong>。如果你去洛谷等OJ上刷题你会明显感觉到：</p><p>竞赛图的题目我都能<strong>看得懂题解</strong>，但要我<strong>自己贺</strong>却没有思路。这时，贺的<strong>套路</strong>就凸显出了它的重要性。</p><blockquote><p>套路如浩瀚的题海中的一座灯塔，指引我们解题的方向。 ——[数据删除]</p></blockquote><p>网上其他的文章会叽里咕噜说一堆东西，常见的有</p><p><strong>怎么SSH——怎么背下 ip 赋——ctrl cv</strong></p><p>可你不妨设想一下，这种套路有实质的作用吗？ 没有，因为前两步会比第三步还要难写。</p><h2 id="一、竞赛图六步走">一、竞赛图六步走</h2><p>注意：这 $6$ 步和所谓的 $SSH$ 完全不同，后面会讲到。</p><ol><li>贺</li><li>贺</li><li>贺</li><li>贺</li><li>贺</li><li>贺</li></ol><h1>二、“六步走”的详解</h1><p>PS：这部分博客会按照六个步骤分为六个小部分，<strong>每部分会以一个口诀结束，并会在下方有相应的解释</strong>，口诀的作用是方便各位大佬<strong>记忆</strong> ，看我多贴心 。</p><p>${\tt}\Huge{[数据删除]大佬太有文采了但是我编不出来口诀，希望有人提供，谢谢}$</p><p>定义：$n$ 个点，任意两点之间有一条有向边的图</p><p>性质：（证明都是瞎写的不保证正确性</p><p>因为 $n=2$ 很奇怪，所以不算进下面的<s>结论</s>套路</p><ol><li><p>竞赛图一定存在一条哈密顿路径</p><p>证明：考虑归纳， $n=1$ 的时候显然成立，现在已经求出 $n-1$ 个点的竞赛图的哈密顿路径了，发现如果第 $n$ 个点连出去的边都是指向其他点或者都是指向自己时，一定可以把这个点放到哈密顿路径首或尾，若不满足上面的条件，则一定存在 $u,v$ 满足有边 $(u,n),(n,v)$ ，直接把 $n$ 放到  $u,v$ 中间就好了</p></li><li><p>竞赛图缩点后成链状</p><p>这里的是呈链状，边都是从拓扑序小的连向拓扑序大的</p><p>证明：发现缩点后还是一张竞赛图，因为竞赛图一定有哈密顿回路，所以呈链状</p></li><li><p>竞赛图的每一个强连通分量都存在哈密顿回路</p><p>证明：跟哈密顿路径考虑方法很像，归纳，$n=1$ 的时候显然成立，还是讨论边的指向，如果都是指向其他点或者都是指向自己时，发现这个点一定自己作为一个 $scc$ ，否则一定可以在他所在的 $scc$ 的环上找到两点 $u,v$ 使得边是 $(u,n),(n,v)$ ，这样一定可以加进去</p></li><li><p>对于一个竞赛图中大小为 $n$ 的强连通分量，其一定存在大小为 $\forall len \in [1,n]$ 的简单环</p><p>证明：考虑 $3$ 的证明，我们对于一个强连通分量是一个点一个点加的，每次加之前都会有环，加之后也有环，所以显然是对的</p><p>因为竞赛图很傻逼，发现 $2$ 个点没有环，会影响到 $n=3$ 所以结论要求 $n \ge 4$ 😠</p></li><li><p>如果 $u$ 的出度大于 $v$ 的出度，则 $u$ 一定可以到达 $v$</p><p>证明：如果 $u,v$ 在一个强连通分量里面显然正确，当不在一个强连通分量时考虑缩点后的拓扑序</p><p>设 $u$ 所在的强连通分量是 $x$，$v$ 所在的强连通分量是 $y$ （注意强连通分量编号是拓扑序倒序</p><p>当 $x&gt;y$ 时，缩点完成链状，显然可以到达</p><p>当 $x&lt;y$ 时，因为缩点完了已经没有环了，所以 $v$ 连出去的点一定是强连通分量标号小于 $y$ 的， $u$ 连出去的点一定是强连通分量标号小于 $x$ 的，又因为 $x&lt;y$ ，所以得出 $u$ 出度小于 $v$ 出度，寄</p></li><li><p>存在竞赛图满足每个点出度序列为 $arr$ 当且仅当将 $arr$ 排序后，$\forall k \sum\limits_{i=1}^{k} arr_i \ge {k \choose 2}$ 且 $\sum\limits_{i=1}^{n} arr_i = {n \choose 2}$ (兰道定理)</p><p>证明：必要性显然</p><p>充分性考虑构造，先让出边集合 $A$ 为 $0,1,2,3…n-1$ ，这显然是可以构造出来的，并且满足上面的条件，现在有一些点不满足，我们换一下边的指向顺序来满足这个条件，设 $x$ 为第一个不满足 $A_x=arr_x$ 的地方，$y$ 为最大的 $A_y=A_x$  ，$z$ 为最小的 $A_z&gt;arr_z$ ，发现 $A_x &lt; arr_x \le arr_y &lt; A_z$ ，所以必定有一个点 $p$ 和 $x,z$ 的关系是边 $(p,x),(z,p)$ 现在只要 $swap$ 一下两条边指向就可以让 $A_x+1\rightarrow A_x,A_z-1\rightarrow A_z$ ，发现这个操作一定是可以一直进行的，所以我们就通过不断调整调整出 $arr$ 来了</p><p>推论：一个竞赛图强连通当且仅当 $\not\exists 1\le k &lt;n,\sum\limits_{i=1}^{k}arr_i={k\choose 2}$</p><p>必要性：对于 $\forall k \in [1,n)$ ，因为我是极大强连通分量的一部分，所以一定有点会指向 $(k,n]$ 的点，又因为我前 $k$ 个点的导出子图是竞赛图，所以 $\sum\limits_{i=1}^{k}arr_i\ge{k\choose 2}+1$</p><p>$\sum\limits_{i=1}^{k}arr_i&gt;{k\choose 2}$</p><p>条件可知前 $k$ 个点组成的导出子图边集大小为 ${k \choose 2}$，所以前 $k$ 个点没有指向后面的点的边，寄</p><p>充分性：跟哈密顿回路很像，归纳，现在已经有 $k$ 个点了，现在加进来第 $k+1$ 个点 $y$ ，我们钦定这个点一定有一条 $\exists x\in S,(x,y)$ 的边，其中 $S$ 是当前选的选的 $k$ 个点的集合，发现加进来后一定是一个强连通分量，又因为给定条件，所以一定能一直找到这个点</p></li></ol><p>坚持看完的都是大佬</p><p>建议各位大佬将本文收藏，多读几遍，口诀最好背过，这样效果最好。 本文的初衷是想让大佬们更加大佬化，WE AK NOIP！！！—— [数据删除] 大佬</p><h2 id="Wait！！！">Wait！！！</h2><p>信奥中有一句通用法则：</p><blockquote><p><strong>题海战术</strong></p></blockquote><p>套路虽然有用，但是不结合题目来<strong>实战</strong>，就等于 <strong>0</strong> ，我们一起来将这个竞赛图套路应用到实际解题当中： （ 竞赛图的核心其实不在思路这块，代码相对而言可以说是呼之欲出的，又<strong>限于篇幅</strong>，后面就<strong>重点讲怎么贺</strong>，代码就省略了哈 ）</p><ol><li>基础应用：<a href="https://www.luogu.com.cn/problem/T235955">牢固的壳子</a></li><li>高级运用：熟练的互联网搜索能力</li><li>赛场应用：$SSH$</li><li>优化：还不赶紧让你贺的那个人优化</li></ol><p>可能你会认为，博主直接复制粘贴一个标程，再敲点注释不是又省事又清楚吗？干嘛非要长篇大论讲一堆没用的这种心情很能理解，但是你要明白</p><p>不会自己贺出来题目的人，贺多少题都没用。信奥的学习是注重贺的，而不是注重自己做的。看了别人的题解得到启发确实可以马上 $AC$ ，但是考场上却不能，因为没有了别人的题解，没有过硬的 $SSH$ 能力，而本博客正是总结了“贺的套路”。 ——[数据删除] 大佬</p><p>后面我会从洛谷中精选一些绿题和蓝题进行讲解，并且每日更新至多 <strong>${\tt}\Huge{0}$</strong> 道题。</p><h2 id="CF1268D-Invertation-in-Tournament"><a href="https://www.luogu.com.cn/problem/CF1268D">CF1268D Invertation in Tournament</a></h2><p>结结结结结结结结结结结论题</p><p>首先先将竞赛图缩点，考虑操作几次可以把这张竞赛图变成一个强连通图</p><p>考虑随便找一个点 $u$ 翻转，假设他在的强连通分量是 $x$ ，发现他一定会向小于 $x$ 的强连通分量连边，而大于 $x$ 的强连通分量一定会向 $x$ 连边（ $tarjan$ 后强连通分量编号是拓扑序倒序），所以反转后就一定是强连通竞赛图了！</p><p>这样我们就做完了……吗？</p><p>发现好像有这么一种可能，我翻转 $u$ 之后 $x$ 会分裂成很多强连通分量，寄！</p><p>但是没有关系，因为我们有<s>结论</s>套路 $4$！，这样我们呢可以保证存在一个点 $u$ 使得翻转之后 $x$ 不会寄！</p><p>然后我们就做完了……吗？</p><p>万一根本没有强连通分量大小大于 $3$ 的就没有这个条件了 🤔</p><p>但是真的寄了吗？发现将一个大小为 $3$ 的强连通竞赛图翻转一个点相当于把他变成两条链，所以只要强连通分量大小小于等于 $3$ 的个数大于 $2$ 就没事了 🙃</p><p>好像 $3$ 个大小为 $1$ 的也会寄，不过没关系，我不想 🤔 了，发现好像要是有那么 $10$ 个点左右就没事了，开摆</p><p>题解说是 $7$ 个点，但是好像没有考虑我上面说的捏（<s>但是上面的只有 $3$ 个点</s></p><p>要是不考虑这 $3$ 个大小为 $1$ 的情况，大概证明就是首先强连通分量个数大于 $2$ 或等于 $1$ 显然正确，要是大小为 $2$ ，那么肯定有一个连通块大小大于 $3$ ，赢！🙃</p><p>然后我们就做完了……吗？</p><p>好像真的做完了……</p><p>注意特判本来就是一个强连通竞赛图</p><p>发现 $tarjan$ 缩点是 $O(n+m)$ 的，寄 😅，不过没关系，还有一个兰道定理推论（<s>结论</s>套路 $6$）可以搞这个玩意</p><ul><li>本次更新时间为2020.5.24</li><li>下次更新时间为2020.5.24</li></ul><p>如果你认为本文对你有帮助的话，请<strong>素质三连</strong>，Thanks♪(･ω･)ﾉ</p>]]></content>
    
    
    
    <tags>
      
      <tag>竞赛图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shabby ds</title>
    <link href="/2023/08/15/shabby%20ds/"/>
    <url>/2023/08/15/shabby%20ds/</url>
    
    <content type="html"><![CDATA[<h4 id="gym103687K-Dynamic-Reachability"><a href="https://codeforces.com/gym/103687/problem/K">gym103687K. Dynamic Reachability</a></h4><p>首先看到这个巨大的时限 $12\operatorname{s}$ ，盲猜一手是 $bitset$ 或者是分块<s>结果两个都有</s></p><p>最直观的想法肯定是直接搜，复杂度是 $O((n+m)q)$ 的，不可以接受，但是这种做法太没有拓展性了，考虑一些有拓展性的做法，发现一般图传递闭包是 $O(\frac{n^3}{\omega})$，但是拓扑图的传递闭包是 $O(\frac{nm}{\omega})$ ，考虑把他缩点成一个拓扑图然后拓扑排序，时间复杂度 $O((n+m+\frac{nm}{\omega})q)$ <s>更加</s>不能接受了，但是这个看起来就比上面那个高级很多，因为我们能求出整张图上每个点能到达的所有点，这个是上面做不到的，而且每次修改只会改一条边，所以图不会产生太大的变化</p><p>这时候就感觉应该是分块了，我们把每 $B$ 个询问放到一块做，设这 $B$ 个操作里面涉及到的点为关键点，涉及到的边为关键边，发现我们就是问关键点的连通性，我们对于每个点维护一个关键点的 $bitset$ ，表示这个点能到达的关键点，通过黑色的非关键边跑拓扑排序求出，这样就在不考虑关键边的情况下建出了不含关键边的关键点新图，因为我 $bitset$ 只维护关键点，所以复杂度就是 $O(\frac{mB}{\omega}q)$</p><p>先不管关键边，思考怎么查询，直观想法是继续拓扑排序，但是这样没有拓展性，因为我不可能建出新图后递归上面那坨答辩算法，因为万一是我建出来的就是拓扑图就寄了不能递归了，所以考虑一开始就提出的 $bfs$ ，发现现在的图很小了，只有 $B$ 个点 $B^2$ 条边，直接跑复杂度是 $O((B+B^2)q)$ 的。</p><p>现在来分析一下复杂度，将上面的答辩加起来是 $O(\frac{q}{B}(n+m+\frac{mB}{\omega})+(B+B^2)q)$ ，化简一下是 $O(\frac{mq}{\omega}+\frac{q}{B}(n+m)+B^2q)$，根号平衡一下 $B$ 发现大概是 $(n+m)^{\frac{1}{3}}$ ，然后就结束了……吗？</p><p>算一下复杂度大概是 $6e8$ 左右，然后我们就开心的写，然后就 $T$ 了 <img src="https://www.emojiall.com/img/platform/qq/074@2x.gif" alt=""></p><p>发现有一个神奇的东西，用 $bitset$ 优化 $bfs$ 可以做到 $O(n+\frac{n^2}{\omega})$ ，现在复杂度就是 $O(\frac{mq}{\omega}+\frac{q}{B}(n+m)+\frac{B^2}{\omega}q)$ 了，复杂度大概是 $2.5e8$ ，我也不知道，反正就是能过了</p><h4 id="gym105065B-Call-Me-Call-Me"><a href="https://codeforces.com/gym/104065/problem/B">gym105065B. Call Me Call Me</a></h4><p>15s 时限我跑了14476 ms。</p><p>lxl 讲的</p>]]></content>
    
    
    
    <tags>
      
      <tag>ds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S2题单：NOIP前建议做的题</title>
    <link href="/2023/08/15/S2%E9%A2%98%E5%8D%95%EF%BC%9ANOIP%E5%89%8D%E5%BB%BA%E8%AE%AE%E5%81%9A%E7%9A%84%E9%A2%98/"/>
    <url>/2023/08/15/S2%E9%A2%98%E5%8D%95%EF%BC%9ANOIP%E5%89%8D%E5%BB%BA%E8%AE%AE%E5%81%9A%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>删掉了一些没意思的题</p><h4 id="P3449-POI2006-PAL-Palindromes"><a href="https://www.luogu.com.cn/problem/P3449">P3449 [POI2006]PAL-Palindromes</a></h4><p>首先有一个结论， $A,B$ 为回文串， $A+B$ 也是回文串当且仅当 $A,B$ 的最小循环节相同</p><p>现在假设是长度为 $n$ 的字符串 $S$ 和 长度为 $m(n \ge m)$ 的字符串 $T$ 拼在一起，现在有 $S+T$ 是一个回文串，所以 $S$ 一个长度为 $T$ 的前置u一定也是回文串，所以 $S+T$ 可以写成 $T+P+T$ 的样子，这样递归下去会变成 $xT+Q+xT$ 的样子，然后我们只保留 $Q+T$ ，现在肯定 $Q$ 的长度小于 $T$ ，对 $Q+T$ 继续重复上述操作直到无法操作，发现肯定是 $Q$ 是 $T$ 的约数的时候停止，不难发现 $Q$ 一定是 $S,T,S+T$ 的循环节，所以 $Q$ 的最小循环节一定是 $S,T$ 的最小循环节</p><p>剩下的就很好做了，直接按最小循环节分类就好了</p><h4 id="P3158-CQOI2011-放棋子"><a href="https://www.luogu.com.cn/problem/P3158">P3158 [CQOI2011]放棋子</a></h4><p>发现我选哪一行那一列不重要，我只要知道选了多少就行了，所以设 $f_{i,j,k}$ 表示考虑了前 $i$ 中颜色的棋子，已经 $j$ 行 $k$ 列有棋子占用了，转移就枚举我当前棋子要用几行几列，再乘上将这些行这些列全部占满的方案数就行了</p><p>现在问题是怎么算方案数，发现这玩意一脸容斥样子，设 $g_{i,j,k}$ 表示用 $i$ 个棋子占满 $j$ 行 $k$ 列的方案数，首先先算出 $i$ 个棋子随便放的方案数，然后减去只放满 $x$ 行 $y$ 列的方案数就行了</p><p><a href="https://www.luogu.com.cn/record/102103914">code</a></p><h4 id="CF314E-Sereja-and-Squares"><a href="https://www.luogu.com.cn/problem/CF314E">CF314E Sereja and Squares</a></h4><p>shabby题</p><p>正解 $O(n^2)$</p><p>注意题目里说了，输入只有<strong>小写字母和问号</strong></p><p>首先有一个显然的 $dp$ ，将小写字母看成左括号，大写字母看成右括号，设 $f_{i,j}$ 表示考虑前 $i$ 个字符，有 $j$ 个左括号的方案数，但是这个常数太大了过不去</p><p>发现只要对于任意的长度为 $i$ 的前缀，里面右括号数量小于 $\frac{i}{2}$ ，就一定能满足题目条件，所以设 $f_{i,j}$ 表示考虑前 $i$ 个字符，有 $j$ 个右括号的方案数，要是小写字母不用管，要是是问好就考虑他填成什么，要是是左括号就是 $f_{i,j}=f_{i-1,j}\times 25$ ，要是是右括号就是 $f_{i,j}=f_{i-1,j-1}$ ，滚动数组就可以过了</p><p><a href="https://codeforces.com/contest/314/submission/207092999">code</a></p><h4 id="CF685B-Kay-and-Snowflake"><a href="https://www.luogu.com.cn/problem/CF685B">CF685B Kay and Snowflake</a></h4><p><s>不知道怎么入选这个题单的</s></p><p>直接暴力就好了</p><p>首先叶子节点的重心一定是本身，考虑不是叶子的怎么求，发现就是我的重儿子的重心往上跳一跳，跳到他上面的子树大小小于等于点数一半，发现每条边最多被跳一次，所以复杂度正确</p><p><a href="https://codeforces.com/contest/685/submission/207093928">code</a></p><h4 id="P3451-POI2007-ATR-Tourist-Attractions"><a href="https://www.luogu.com.cn/problem/P3451">P3451 [POI2007]ATR-Tourist Attractions</a></h4><p>不是很难的状压，设 $f_{s,i}$ 表示我现在走过的点集合为 $s$ ，我现在在点 $i$ 的最小代价，转移就枚举下一个点是什么点就好了，时间复杂度 $O(2^n n^2)$ ，但是这样空间是 $80MB$ ，用<a href="https://www.luogu.com.cn/problem/P6622">信号传递</a>的卡空间技巧随便卡卡就好了，我的卡法是把 $S$ 去掉点 $i$ ，这样空间小一半，就能过了</p><p><a href="https://www.luogu.com.cn/record/111186134">code</a> <s>抽象</s></p><h4 id="CF1043F-Make-It-One"><a href="https://www.luogu.com.cn/problem/CF1043F">CF1043F Make It One</a></h4><p>想到了答案 $\le 7$ ，但是去想根号分治了<s>然后误以为 $\sqrt n$ 内质数只有 $6$ 个</s></p><p>首先答案 $\le 7$ 很显然，考虑要是求出一个有 $8$ 个数的答案，考虑这个数有用当且仅当存在一个质因数只有我没有并且其他数都有，而 $3e5$ 最多只有六个质因数，加上一个特殊情况 $3\times 5\times 7\times 9\times 11\times 13 \times 17$ （即前六个没有 $17$ ，这个没有 $2$ ），所以最多只有 $7$ 个质数，又因为只能我有，所以一个质数最多让答案变大 $1$ ，所以答案 $\le 7$</p><p>现在考虑怎么求这个玩意，因为答案 $\le 7$ ，可以先枚举一手答案大小，发现我还是不会算 $\gcd=1$ 的，但是我会算 $\gcd$ 是 $x$ 的倍数，具体来说就是要是有 $sum$ 个数是 $x$ 的倍数，方案数就是 $sum \choose k$ （ $k$ 为枚举的答案），然后容斥就好了</p><p><a href="https://codeforces.com/contest/1043/submission/207108539">code</a></p><h4 id="AGC013E-Placing-Squares"><a href="https://www.luogu.com.cn/problem/AT_agc013_e">[AGC013E] Placing Squares</a></h4><p>考虑组合意义，现在等于是有 $n$ 个盒子，你要放插板把盒子分隔成若干段，每两个插板中间要恰好有一个黑球和一个白球，可以放在一个盒子里，求方案数</p><p>考虑 $dp$</p><p>$f_{i,0}=f_{i,0}+f_{i,2}$ 第一个表示不放球不插板，第二个表示不放球插板</p><p>$f_{i,1}=2f_{i,0}+f_{i,1}+2f_{i,2}$ 第一个表示放球（两种球都可以）不插板，第二个表示不放球不插板，第三个表示放球插板</p><p>$f_{i,2}=f_{i,0}+f_{i,1}+2f_{i,2}$ 第一个表示放球（两个都放这里）不插板，第二个表示放球（只剩一个了）不插板，第三个表示放球（两个都放这里）插板或不放球不插板</p><p>同理不能插板的也一样，把上面有插板的转移去掉就行了</p><p>这玩意显然可以矩阵快速幂优化，时间复杂度 $O(m\log n)$ 常数有 $27$ 😔 ，预处理出所有 $2$ 的整次幂然后用矩阵乘向量应该能优化掉一个 $3$ ，但是我摆了</p><p><a href="https://atcoder.jp/contests/agc013/submissions/41695339">code</a></p><h4 id="P3643-APIO2016-划艇"><a href="https://www.luogu.com.cn/problem/P3643">P3643 [APIO2016] 划艇</a></h4><p>首先肯定不能直接记下来每个学校有多少划艇，肯定是要离散化的，设 $c_i$ 为离散化后的数组 ，设 $f_{i,j}$ 表示第 $i$ 个学校派划艇，并且我的划艇数目是在 $[c_{j-1},c_j)$ 的方案数，但是我们还是不知道离散化后 $f_{i,j}$ 能不能从 $f_{k,j}$ 转移过来</p><p>然后就有了一个神奇的东西：给一个长度为 $n$ 的数组 $a$ 赋值，其中 $0 \le a_i \le m$ ，是其中的非 $0$ 项递增的方案数是 $n+m \choose n$ ，首先假设不能选 $0$ ，那么显然就是 $m \choose n$ ，现在可以不选，就等于在前面加上 $n$ 个 $0$ ，也可以选 $0$ 表示不选这个数，所以是 $n+m \choose n$</p><p>现在就很好 $dp$ 了，考虑我在转移 $f_{i,j}$ 的时候枚举一个 $k$ ，让 $(k,i]$ 的学校派的划艇都在 $[c_{j-1},c_j)$ 中，注意这段中有可能 $[a_x,b_x]$ 不包含 $[c_{j-1},c_j)$ ，还有就是因为状态钦定了第 $i$ 个必须在 $[c_{j-1},c_j)$ 中，所以组合数是 $n+m-1 \choose n$</p><p>转移方程：$f_{i,j}=\sum\limits_{k=0}^{i-1}{sum+c_j-c_{j-1}-1 \choose sum} \sum\limits_{t=0}^{j-1} f_{k,t}$ ， $sum$ 是 $[a_x,b_x]$ 包含 $[c_{j-1},c_j)$ 并且 $x &lt; i$ 的 $x$ 的个数</p><p>这样是 $O(n^4)$ 的，前缀和优化一下就好了</p><p><a href="https://www.luogu.com.cn/record/111253197">code</a></p><h4 id="P3452-POI2007-BIU-Offices"><a href="https://www.luogu.com.cn/problem/P3452">P3452 [POI2007]BIU-Offices</a></h4><h4 id="P3188-HNOI2007-梦幻岛宝珠"><a href="https://www.luogu.com.cn/problem/P3188">P3188 [HNOI2007]梦幻岛宝珠</a></h4><h4 id="CF1166E-The-LCMs-Must-be-Large"><a href="https://www.luogu.com.cn/problem/CF1166E">CF1166E The LCMs Must be Large</a></h4><h4 id="CF1045H-Self-exploration"><a href="https://www.luogu.com.cn/problem/CF1045H">CF1045H Self-exploration</a></h4><h4 id="P3474-POI2008-KUP-Plot-purchase"><a href="https://www.luogu.com.cn/problem/P3474">P3474 [POI2008]KUP-Plot purchase</a></h4><h4 id="CF1032F-Vasya-and-Maximum-Matching"><a href="https://www.luogu.com.cn/problem/CF1032F">CF1032F Vasya and Maximum Matching</a></h4><h4 id="ARC087F-Squirrel-Migration"><a href="https://www.luogu.com.cn/problem/AT_arc087_d">[ARC087F] Squirrel Migration</a></h4><p>首先先思考一下答案上界，对于每条边考虑贡献，断掉这条边后这棵树分成两棵树 $S_1,S_2$ ，不妨设 $|S_1|&lt;|S_2|$ ，不难发现这条边的贡献最多是 $2|S_1|$ ，盲猜一首答案就是 $\sum\limits_{(u,v)} 2|S_1|$ ，不难发现这个是肯定能取到的，下面有一个构造方案</p><p>从点 $1$ 到点 $n$ 依次寻找 $p_i$ ，对于点 $i$ ，先转到根，$p_i$ 就是从 $i$ 开始的重链的另一头的点，$p_i$ 的 $p_{p_i}$ 就是 $i$，然后将 $p_i$ 删去</p><h4 id="P5307-COCI2018-2019-6-Mobitel"><a href="https://www.luogu.com.cn/problem/P5307">P5307 [COCI2018-2019#6] Mobitel</a></h4><p>$SSH$ 的 <a href="https://www.luogu.com.cn/blog/Karry5307/solution-p5307">$Karry5307$</a> 的</p><p>没见过 😔</p><p>首先有一个非常 $naive$ 的方程就是设 $f_{i,j,k}$ 表示我到达了$i,j$ 这个点，现在权值是 $k$ 的方案数，但是这样是 $O(rsn)$ 的，直接寄，但是乘除有一个很神奇的东西，整除分块，现在我们换一个状态， $f_{i,j,k}$ 表示我到达了$i,j$ 这个点，现在权值至少乘 $k$ 的才能到达 $n$ 方案数，因为 $\lfloor\frac{\lfloor \frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{ \frac{a}{b}}{c}\rfloor$ ，所以这个转移显然是可以进行的，发现有用的 $k$ 只有 $\sqrt n$ 个，所以复杂度变成了 $O(rs\sqrt n)$ 可以通过</p><p>卡空间，记得滚动数组</p><p><a href="https://www.luogu.com.cn/record/111270680">code</a> <s>代码是屎</s></p>]]></content>
    
    
    
    <tags>
      
      <tag>题单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>re从零开始的化学生活</title>
    <link href="/2023/08/15/re%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8C%96%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    <url>/2023/08/15/re%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8C%96%E5%AD%A6%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="肯定有误，感谢指正">肯定有误，感谢指正</h2><p><s>因为本人一点也不想学whk，所以很可能瞎写</s></p><h3 id="物质分类及转化">物质分类及转化</h3><p>游离态：元素以单质形式存在的状态（$S$</p><p>化合态：元素以化合物形式存在的状态（$Na,K$</p><p>同素异形体：同种元素形成的不同单质</p><ol><li>原子个数不同（$O_2,O_3$</li><li>原子排列方式不同（金刚石，石墨，$P$：白磷，红磷，$Sn$：白锡（有延展性），灰锡（粉末状）温度低时变为灰锡</li></ol><p>同素异形体之间的性质差异主要体现在物理性质上，同素异形体之间的转化属于化学变化</p><p><strong>氧化物</strong>：氧元素和另外一种化学元素组成的<strong>二元</strong>化合物</p><p><img src="https://sjzezoj.com/image_hosting/0l3pboybus.png" alt=""></p><p>成盐氧化物：可以通过化学反应从氧化物转变成盐</p><p>酸性氧化物：可以和<strong>碱</strong>反应，生成<strong>一种</strong>盐+水</p><p>碱性氧化物：可以和<strong>酸</strong>反应，生成<strong>一种</strong>盐+水</p><p>两性氧化物：可以和<strong>酸和碱</strong>反应，生成<strong>一种</strong>盐+水 $Al_2O_3+6HCL=2AlCl_3+3H_2O,Al_2O_3+2NaOH=2NaAlO_2+H_2O$</p><p>$Fe_3O_4$ ：化合价有$+2,+3$，生成两种盐</p><p>过氧化物：还会生成氧气</p><p>酸性氧化物不一定是非金属氧化物 $Mn_2O_7+2KOH=2KMnO_4+H_2O$</p><p>关于（非）金属氧化物与酸（碱）性氧化物：</p><p>唯一正确：碱性氧化物一定是金属氧化物</p><h3 id="分散系和胶体">分散系和胶体</h3><p>被分散成粒子的物质叫做分散质，另一种物质叫做分散剂</p><p>根据分散质例子直径大小分类：</p><p><img src="https://sjzezoj.com/image_hosting/augqwcgchv.png" alt=""></p><p>雾：液态小水滴被空气分散</p><p>烟：固体小颗粒被空气分散</p><p>胶体处于介稳体系，可以通过滤纸，不可以通过半透膜</p><p>例子：$Fe(OH)_3$ 胶体，豆浆</p><p>胶体的制备：<br>$$<br>\ce{FeCl_3 + 3H_2O-&gt;[加热]Fe(OH)_3(胶体) + 3HCl}<br>$$</p><p>$$<br>\ce{Fe^3+ + 3H_2O-&gt;[加热]Fe(OH)_3(胶体) + 3H+}<br>$$</p><p>至红褐色停止加热</p><p><strong>制备时要用蒸馏水，自来水中离子会使胶体沉淀，不能使用玻璃棒</strong></p><p>胶体性质：</p><p><img src="https://sjzezoj.com/image_hosting/qlj6f901y7.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/7tuwskbf07.png" alt=""></p><h3 id="电解质">电解质</h3><p>在水溶液或熔融状态下能够导电的化合物是电解质</p><p>电解质和非电解质都是化合物</p><p>有些化合物水溶液能导电，但溶液中的离子不是该化合物自身所电离产生的，所以<strong>属于非电解质</strong>（$CO_2,SO_2,SO_3,NH_3$等</p><p>电解质和溶解性没有关系（$BaSO_4$</p><p>电离：电解质溶于水或受热熔化时，形成自由移动离子的过程</p><p>强电解质：在水溶液（熔融状态）能<strong>完全</strong>电离的电解质</p><ol><li>强酸：$HClO_4,HI,HBr,HNO_3,H_2SO_4$</li><li>强碱：$NaOH,KOH,Ca(OH)_2,Ba(OH)_2$</li><li>大多数盐：$NaCl,KI,Ca(NO_3)_2,CH_3COONa,NH_4Cl,BaSO_4$</li><li>活泼金属氧化物：$Na_2O,MgO,CaO,Al_2O_3$</li></ol><p>纯水是极弱的电解质</p><p>电解质的强弱与溶液的导电性没有必然关系，强弱取决于溶液中自由移动的<strong>离子浓度</strong></p><h3 id="离子方程式">离子方程式</h3><p><img src="https://sjzezoj.com/image_hosting/l41t5c8rya.png" alt=""></p><h4 id="拆：">拆：</h4><p>能拆写成离子的物质必须同时具备易溶，易电离这两个条件</p><p>单质，氧化物（$CuO$，气体，难溶物（$CaCO_3$，弱电解质</p><p>摆了只放截图吧</p><p><img src="https://sjzezoj.com/image_hosting/1gzg8v3jud.png" alt=""></p><h3 id="离子共存">离子共存</h3><h4 id="当溶液无色时，有色离子不会大量共存">当溶液无色时，有色离子不会大量共存</h4><p>$Cu^{2+}$ ：蓝色</p><p>$Fe^{2+}$ ：浅绿</p><p>$Fe^{3+}$ ：蓝色</p><p>$MnO_4^-$ ：紫色</p><p>$CrO_4^{2-}$ ： 黄色</p><p>$CrO_7^{2-}$ ：橙色</p><p>透明溶液 $\neq$ 无色溶液</p><h4 id="溶液呈酸性时，与-H-反应的离子无法大量存在">溶液呈酸性时，与 $H^+$ 反应的离子无法大量存在</h4><p>与 $H^+$ 反应：$OH^-$ 和弱酸根离子，即除了 $ClO_4^-,I^-,Br^-,Cl^-,NO_3^-,SO_4^-$ 的酸根离子</p><h4 id="溶液呈碱性时，与-OH-反应的离子无法大量存在">溶液呈碱性时，与 $OH^-$ 反应的离子无法大量存在</h4><p>与 $OH^-$ 反应：$H^+,NH_4^+$ 和与氢氧根形成沉淀的金属阳离子，即除了 $Na^+,K^+,Ba^{2+}，Ca^{2+}$ 的金属阳离子</p><h4 id="无论强酸性还是强碱性都无法大量共存的离子">无论强酸性还是强碱性都无法大量共存的离子</h4><p>弱酸的酸式根离子（$HCO_3^-,HSO_3^-,HS^-,H_2PO_4^{2-},HPO_4^{2-},HC_2O_4^-$</p><h4 id="常见的难溶物-微溶物">常见的难溶物/微溶物</h4><p>好多呀继续开摆</p><p><img src="https://sjzezoj.com/image_hosting/ynmx4dp65k.png" alt=""></p><h4 id="离子间发生氧化还原反应不共存">离子间发生氧化还原反应不共存</h4><p><img src="https://sjzezoj.com/image_hosting/tae3m1onur.png" alt=""></p><h3 id="氧化还原">氧化还原</h3><p>氧化反应：失 $e^-$ 化合价升高</p><p>还原反应：得 $e^-$ 化合价降低</p><p>氧化剂：帮助别人氧化的物质，本身被还原，得 $e^-$</p><p>还原剂：帮助别人还原的物质，本身被氧化，失 $e^-$</p><p>抗氧化剂：很容易被氧化</p><p>氧化性：物质得 $e^-$ 能力 ，氧化剂强弱</p><p>氧化性：物质失 $e^-$ 能力 ，还原剂强弱</p><p>氧化产物：被氧化所生成的产物</p><p>还原产物：被还原所生成的产物</p><h4 id="常见氧化剂与还原剂">常见氧化剂与还原剂</h4><p><img src="https://sjzezoj.com/image_hosting/ufv35ts6oo.png" alt=""></p><p>若元素处于最高价态，则只表现氧化性（$KMnO_4$的 $Mn, +7$ ,$HNO_3$ 的 $N,+5$</p><p>若元素处于最低价态，则只表现还原性（$S^{2-},Cl^-,Br^-,I^-$</p><p>处于中间价态都可以（$Fe^{2 +}$</p><h3 id="电子转移的表达方式">电子转移的表达方式</h3><h4 id="双线桥法">双线桥法</h4><p>表示<strong>同一元素</strong>反应前后变化</p><p><img src="https://sjzezoj.com/image_hosting/zfcozb5daw.png" alt=""></p><h4 id="单线桥法">单线桥法</h4><p>表示反应物之间的电子转移</p><p><img src="https://sjzezoj.com/image_hosting/6h3szd41pf.png" alt="">****</p><h3 id="氧化还原反应的强弱规律">氧化还原反应的强弱规律</h3><p>氧化性：氧化剂 $&gt;$ 氧化产物</p><p>还原性：还原剂 $&gt;$ 还原产物</p><p>越强的氧化剂变成的还原产物还原性越弱</p><p>当有一氧化剂（还原剂）和多种还原剂（氧化剂）时，还原剂（氧化剂）强的先反应</p><p>还原性顺序（被氧化顺序）：</p><p><img src="https://sjzezoj.com/image_hosting/25sk0tvkqh.png" alt=""></p><p><s>不会再字母头上写东西只能截图</s></p><p>留（硫）一点（碘）铁（铁）生锈（溴）长绿（氯）毛（锰）</p><h3 id="价态归中规律和歧化规律">价态归中规律和歧化规律</h3><p>价态归中规律：同种元素不同价态之间发生反应，元素的<strong>化合价只向中间靠拢而不交叉</strong></p><p>歧化规律：<strong>同一物质，同一价态，同一元素</strong>，既被氧化又被还原的反应</p><p>歧化反应的特点是氧化剂和还原剂是同一种物质</p><p>$Cl_2+2NaOH=NaCl+NaClO+H_2O$</p><h3 id="氧化还原方程式">氧化还原方程式</h3><p><s>反正我少学一点没人知道</s></p><h3 id="钠">钠</h3><p>密度 $\rho_水 &gt; \rho_钠 &gt; \rho_{煤油}$</p><p>熔点低于100°C</p><p>质地柔软，轻压变形，可以用小刀切割</p><p>具有很强的还原性</p><p>$4Na+O_2=2Na_2O$ （失去金属光泽）<br>$$<br>\ce{2Na + O2-&gt;[加热]Na2O2}(淡黄色)<br>$$</p><p>$$<br>\ce{Na-&gt;[O2]Na2O-&gt;[H2O]NaOH-&gt;[CO2]Na2CO3·10H2O-&gt;Na2CO3}<br>$$</p><p>钠单质与水反应：</p><p>$2Na+H_2O=2NaOH+H_2\uparrow$</p><p>$2Na+H_2O=2Na^++2OH^-+H_2\uparrow$</p><p>实验：将绿豆大的钠放入水中</p><p>现象：浮（密度小），熔（熔点低，反应放热），游（生成 $H_2$），响（生成 $H_2$），红（生成 $NaOH$ ）</p><p>钠单质与盐溶液的反应：</p><p>先跟水反应</p><p>$2Na+2H_2O=2NaOH+H_2 \uparrow$</p><p>$CuSO_4+2NaOH=Cu(OH)_2\downarrow+Na_2SO_4$</p><h4 id="氧化钠与过氧化钠比较">氧化钠与过氧化钠比较</h4><p>过氧化钠是过氧根离子</p><p><img src="https://sjzezoj.com/image_hosting/vy5sdv1hrq.png" alt=""></p><p><img src="https://sjzezoj.com/image_hosting/fohbdnkpfo.png" alt=""></p><h4 id="碳酸钠与碳酸氢钠比较">碳酸钠与碳酸氢钠比较</h4>]]></content>
    
    
    
    <tags>
      
      <tag>文化课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种求第 k 小方案的神奇做法</title>
    <link href="/2023/08/15/%E4%B8%80%E7%A7%8D%E6%B1%82%E7%AC%AC%20k%20%E5%B0%8F%E6%96%B9%E6%A1%88%E7%9A%84%E7%A5%9E%E5%A5%87%E5%81%9A%E6%B3%95/"/>
    <url>/2023/08/15/%E4%B8%80%E7%A7%8D%E6%B1%82%E7%AC%AC%20k%20%E5%B0%8F%E6%96%B9%E6%A1%88%E7%9A%84%E7%A5%9E%E5%A5%87%E5%81%9A%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><s>同样适用于前 k 大</s></p><p>肯定对于每一个方案 $x$ 都会有一个 $val(x)$ 表示这种方案的权值。</p><p>我们定义对于一个集合的 $val$ 是 $val(S)=\min\limits_{x\in S}{val(S)}$，首先需要找到一个集合 $S$ 使得 $val(S)$ 是最小的权值，对 $S$ 定义一个 $trans(S)$ 表示 $S$ 能变换到的集合的集合，一般这个 $trans$ 是一个固定的变换方法，这里需要满足 $T \in trans(S) ,val(T) \ge val(S)$ 并且对于任意一个不是权值最小的方案 $T$ 都存在且一个 $S$ 使得 $T \in trans(S)$，这样能保证我们拓展到的集合权值是逐渐递增的。</p><p>考虑我们如何维护这个东西，我们用一个堆维护当前的已经被拓展到的方案，取出 $val$ 最小的方案 $S$，然后将 $trans(S)$ 中没有加进过堆的集合全部加入堆中，将 $S$ 弹出堆，重复操作，不难发现我们第 $i$ 弹出堆的元素一定是第 $i$ 小，因为根据上面 $trans$ 的定义是一定能变换到所有方案的，并且从最小方案到当前方案的路径上 $val$ 是递增的，我们这样拓展 $k$ 次一定能找到第 $k$ 小的元素，我们设 $sz$ 表示 $trans$ 集合的大小，$ds$ 表示从集合中找到最大值的复杂度，判断集合是否加进过堆的复杂度是 $O(chk)$，这样时间复杂度是 $O(k\cdot sz\cdot ds\cdot (chk+\log(k\cdot sz)))$，非常优秀。</p><p>题目：</p><h3 id="P2048-NOI2010-超级钢琴"><a href="https://www.luogu.com.cn/problem/P2048">P2048 [NOI2010] 超级钢琴</a></h3><p>题意：给你一个长度为 $n$ 序列 $A$，求前 $k$ 大的长度属于 $[l,r]$ 的区间 $a_i$ 和。</p><p>$n,k \le 5 \times 10^5,-1000 \le a_i \le 1000$。</p><p>发现区间不好做，先做前缀和转换成 $\max(a_r-a_l)$，发现对于每一个左端点 $x$ 都有一个 $[l,r]$ 表示右端点能在的位置，我们用堆维护五元组 $S=\left{x,l,r,val,pos\right}$ 表示左端点是 $x$ ，右端点选的区间是 $[l,r]$ ，当右端点选 $pos$ 时是最优的，权值为 $val$ ，不难发现 $trans(S)=\left{\left{x,l,pos-1,val_{l,pos-1},pos_{l,pos-1}\right},\left{x,pos+1,r,val_{pos+1,r},pos_{pos+1,r}\right}\right}$，发现 $pos$ 肯定是 $[l,r]$ 中 $a_i$ 最大的 $i$ ，这个可以直接用 $st$ 表维护，$val$ 也就很好算了，这里 $sz=2,ds=O(\log n)$，不会有重复集合加入堆，所以时间复杂度 $O(k \log k\log n)$。</p><p><a href="https://www.luogu.com.cn/problem/P5283">异或粽子</a>和上面那道题基本一样，就不详细说了。</p><h3 id="P6230-BalticOI-2019-Day2-奥运会"><a href="https://www.luogu.com.cn/problem/P6230">P6230 [BalticOI 2019 Day2]奥运会</a></h3><p>题意：有 $n$ 个人，$k$ 个比赛，第 $i$ 个人在第 $j$ 场比赛中的得分是 $a_{i,j}$ 现在一支队伍要选 $k$ 个人，这支队伍每一场比赛的得分为得分最高的那个人的得分，这支队伍的得分为所有比赛的得分的和，现在问你得分第 $C$ 大的队伍的得分</p><p>$n\le500,k \le6,C\le2000$</p><p>蒟蒻瞎想的做法：<a href="https://sjzezoj.com/blog/2022guohaochen/post/912">link</a></p><p>洛谷题解做法：</p><p>首先这个数据范围非常小，所以我们设的一些东西可以非常暴力。</p><h3 id="P6646-CCO2020-Shopping-Plans"><a href="https://www.luogu.com.cn/problem/P6646">P6646 [CCO2020] Shopping Plans</a></h3><p>非常牛逼的一道题！</p><p>分成几部分来考虑这道题</p><h4 id="Part1">Part1</h4><blockquote><p>$a_i=1,x=y$</p></blockquote><p>这个还是比较简单的，首先最小值肯定是选前 $x$ 个，然后考虑怎么设计 $trans$，</p>]]></content>
    
    
    
    <tags>
      
      <tag>求第 k 小</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
